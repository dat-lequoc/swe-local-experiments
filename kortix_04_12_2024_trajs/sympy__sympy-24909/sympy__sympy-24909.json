{
  "instance_id": "sympy__sympy-24909",
  "model_patch": "diff --git a/sympy/physics/units/prefixes.py b/sympy/physics/units/prefixes.py\nindex ca6a642156..c2382dd57b 100644\n--- a/sympy/physics/units/prefixes.py\n+++ b/sympy/physics/units/prefixes.py\n@@ -6,6 +6,7 @@\n \"\"\"\n from sympy.core.expr import Expr\n from sympy.core.sympify import sympify\n+from sympy.physics.units.quantities import Quantity\n \n \n class Prefix(Expr):\n@@ -79,22 +80,39 @@ def __repr__(self):\n                 str(self.name), str(self.abbrev), self._exponent, self.base)\n \n     def __mul__(self, other):\n-        from sympy.physics.units import Quantity\n         if not isinstance(other, (Quantity, Prefix)):\n             return super().__mul__(other)\n \n         fact = self.scale_factor * other.scale_factor\n \n-        if fact == 1:\n-            return 1\n-        elif isinstance(other, Prefix):\n+        if isinstance(other, Prefix):\n+            if fact == 1:\n+                return 1\n             # simplify prefix\n             for p in PREFIXES:\n                 if PREFIXES[p].scale_factor == fact:\n                     return PREFIXES[p]\n             return fact\n-\n-        return self.scale_factor * other\n+        elif isinstance(other, Quantity):\n+            # Create a new prefixed quantity\n+            prefixed = Quantity(str(self.name) + str(other.name),\n+                              abbrev=str(self.abbrev) + str(other.abbrev),\n+                              is_prefixed=True)\n+            from sympy.physics.units import UnitSystem\n+            UnitSystem._quantity_dimensional_equivalence_map_global[prefixed] = other\n+            UnitSystem._quantity_scale_factors_global[prefixed] = (self.scale_factor, other)\n+            return prefixed\n+\n+    def __rmul__(self, other):\n+        if isinstance(other, Quantity):\n+            return self * other\n+        return super().__rmul__(other)\n+\n+    def __rmul__(self, other):\n+        # Handle reverse multiplication\n+        if type(other).__name__ == 'Quantity':\n+            return self * other\n+        return super().__rmul__(other)\n \n     def __truediv__(self, other):\n         if not hasattr(other, \"scale_factor\"):\n@@ -216,4 +234,4 @@ def prefix_unit(unit, prefixes):\n     'Ti': tebi,\n     'Pi': pebi,\n     'Ei': exbi,\n-}\n+}\n\\ No newline at end of file\ndiff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 8a7ae3a2c4..698305c128 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -83,3 +83,16 @@ def test_bases():\n def test_repr():\n     assert eval(repr(kilo)) == kilo\n     assert eval(repr(kibi)) == kibi\n+\n+def test_prefix_unit_multiplication():\n+    from sympy.physics.units import watt, volt, meter\n+    from sympy.physics.units.prefixes import milli, kilo, centi\n+    # Test both multiplication orders\n+    assert milli * watt == watt * milli\n+    assert kilo * volt == volt * kilo\n+    # Verify scale factors are correctly applied\n+    assert (milli * watt).scale_factor == 0.001\n+    assert (watt * milli).scale_factor == 0.001\n+    # Test with different prefixes\n+    assert centi * meter == meter * centi\n+    assert (centi * meter).scale_factor == 0.01\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}