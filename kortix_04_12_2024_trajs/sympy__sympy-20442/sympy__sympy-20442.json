{
  "instance_id": "sympy__sympy-20442",
  "model_patch": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex fe8a84570c..de542c1566 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,5 +1,6 @@\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n+from sympy.physics.units.definitions import (joule, kilogram, meter, second)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n                                  volume, kilometer)\n from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n@@ -35,6 +36,11 @@ def test_convert_to():\n     q.set_global_relative_scale_factor(S(5000), meter)\n \n     assert q.convert_to(m) == 5000*m\n+    \n+    # Test for incompatible unit conversions\n+    assert joule*second == convert_to(joule*second, joule*second)\n+    assert joule*second == convert_to(joule*second, joule)  # Should return original if incompatible\n+    assert convert_to(joule*second, kg*m**2/second) == kilogram*meter**2/second\n \n     assert speed_of_light.convert_to(m / s) == 299792458 * m / s\n     # TODO: eventually support this kind of conversion:\n@@ -479,4 +485,4 @@ def test_deprecated_quantity_methods():\n         step.set_dimension(length)\n         step.set_scale_factor(2*meter)\n         assert convert_to(step, centimeter) == 200*centimeter\n-        assert convert_to(1000*step/second, kilometer/second) == 2*kilometer/second\n+        assert convert_to(1000*step/second, kilometer/second) == 2*kilometer/second\n\\ No newline at end of file\ndiff --git a/sympy/physics/units/util.py b/sympy/physics/units/util.py\nindex b03ed4cd88..48900d8834 100644\n--- a/sympy/physics/units/util.py\n+++ b/sympy/physics/units/util.py\n@@ -15,23 +15,68 @@ def _get_conversion_matrix_for_expr(expr, target_units, unit_system):\n \n     dimension_system = unit_system.get_dimension_system()\n \n+    # Get dimensions and dependencies\n     expr_dim = Dimension(unit_system.get_dimensional_expr(expr))\n-    dim_dependencies = dimension_system.get_dimensional_dependencies(expr_dim, mark_dimensionless=True)\n+    expr_deps = dimension_system.get_dimensional_dependencies(expr_dim, mark_dimensionless=True)\n     target_dims = [Dimension(unit_system.get_dimensional_expr(x)) for x in target_units]\n-    canon_dim_units = [i for x in target_dims for i in dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True)]\n-    canon_expr_units = {i for i in dim_dependencies}\n-\n+    \n+    # For multiple target units, check if all have compatible dimensions\n+    if len(target_units) > 1:\n+        base_deps = dimension_system.get_dimensional_dependencies(target_dims[0], mark_dimensionless=True)\n+        for dim in target_dims[1:]:\n+            curr_deps = dimension_system.get_dimensional_dependencies(dim, mark_dimensionless=True)\n+            if curr_deps != base_deps:\n+                return None\n+    \n+    target_deps = dimension_system.get_dimensional_dependencies(target_dims[0], mark_dimensionless=True)\n+    \n+    # Check dimensional compatibility\n+    if expr_deps != target_deps:\n+        # For single target unit, check if it's a valid subset\n+        if len(target_units) == 1:\n+            base_deps = {k: v for k, v in target_deps.items() if v != 0}\n+            if not all(k in expr_deps and expr_deps[k] == v \n+                      for k, v in base_deps.items()):\n+                return None\n+        else:\n+            # For multiple targets, dimensions must match exactly\n+            return None\n+            \n+    # Get canonical units\n+    canon_dim_units = []\n+    seen = set()\n+    for x in target_dims:\n+        deps = dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True)\n+        for i in deps:\n+            if i not in seen:\n+                canon_dim_units.append(i)\n+                seen.add(i)\n+                \n+    # Verify unit compatibility\n+    canon_expr_units = {i for i in expr_deps}\n     if not canon_expr_units.issubset(set(canon_dim_units)):\n         return None\n-\n-    seen = set()\n-    canon_dim_units = [i for i in canon_dim_units if not (i in seen or seen.add(i))]\n-\n-    camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) for i in target_dims] for j in canon_dim_units])\n-    exprmat = Matrix([dim_dependencies.get(k, 0) for k in canon_dim_units])\n-\n-    res_exponents = camat.solve_least_squares(exprmat, method=None)\n-    return res_exponents\n+        \n+    # Calculate conversion matrix\n+    try:\n+        camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) \n+                        for i in target_dims] for j in canon_dim_units])\n+        exprmat = Matrix([expr_deps.get(k, 0) for k in canon_dim_units])\n+        \n+        # For time units, ensure proper conversion\n+        if any('time' in str(x) for x in canon_dim_units):\n+            if len(target_units) > 1:\n+                # Check if time units are compatible\n+                time_units = [x for x in target_units if 'time' in str(x)]\n+                if len(time_units) > 1:\n+                    time_deps = [dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True) \n+                               for x in time_units]\n+                    if not all(x == time_deps[0] for x in time_deps[1:]):\n+                        return None\n+                        \n+        return camat.solve_least_squares(exprmat, method=None)\n+    except:\n+        return None\n \n \n def convert_to(expr, target_units, unit_system=\"SI\"):\n@@ -191,4 +236,4 @@ def check_dimensions(expr, unit_system=\"SI\"):\n             reps[m] = m.func(*[\n                 i for i in m.args if not i.is_number])\n \n-    return expr.xreplace(reps)\n+    return expr.xreplace(reps)\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}