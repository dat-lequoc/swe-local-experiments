{
  "instance_id": "django__django-14016",
  "model_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..9be62747d9 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -7,6 +7,7 @@ circular import difficulties.\n \"\"\"\n import copy\n import functools\n+import pickle\n import inspect\n from collections import namedtuple\n \n@@ -38,7 +39,32 @@ class Q(tree.Node):\n     conditional = True\n \n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n-        super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n+        processed_args = []\n+        for arg in args:\n+            if isinstance(arg, tuple):\n+                processed_args.append((arg[0], self._safe_copy_value(arg[1])))\n+            else:\n+                processed_args.append(arg)\n+        processed_kwargs = {k: self._safe_copy_value(v) for k, v in kwargs.items()}\n+        super().__init__(\n+            children=[*processed_args, *sorted(processed_kwargs.items())],\n+            connector=_connector,\n+            negated=_negated\n+        )\n+\n+    @staticmethod\n+    def _safe_copy_value(value):\n+        \"\"\"Safely copy a value, converting non-pickleable iterables to lists.\"\"\"\n+        if isinstance(value, type({}.keys())):\n+            return list(value)\n+        if hasattr(value, '__iter__') and not isinstance(value, (str, bytes, dict)):\n+            try:\n+                # Try pickle-safety test\n+                pickle.dumps(value)\n+                return value\n+            except (TypeError, pickle.PicklingError):\n+                return list(value)\n+        return value\n \n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n@@ -46,10 +72,18 @@ class Q(tree.Node):\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n-            return copy.deepcopy(self)\n+            obj = type(self)()\n+            obj.connector = self.connector\n+            obj.negated = self.negated\n+            obj.children = [(k, self._safe_copy_value(v)) for k, v in self.children]\n+            return obj\n         # Or if this Q is empty, ignore it and just use `other`.\n         elif not self:\n-            return copy.deepcopy(other)\n+            obj = type(self)()\n+            obj.connector = other.connector\n+            obj.negated = other.negated\n+            obj.children = [(k, self._safe_copy_value(v)) for k, v in other.children]\n+            return obj\n \n         obj = type(self)()\n         obj.connector = conn\n@@ -320,4 +354,4 @@ class FilteredRelation:\n         # Resolve the condition in Join.filtered_relation.\n         query = compiler.query\n         where = query.build_filtered_relation_q(self.condition, reuse=set(self.path))\n-        return compiler.compile(where)\n+        return compiler.compile(where)\n\\ No newline at end of file\ndiff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex 9adff07ef2..99a0fad4f0 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -103,3 +103,15 @@ class QTests(SimpleTestCase):\n         q = q1 & q2\n         path, args, kwargs = q.deconstruct()\n         self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_combine_with_dict_keys(self):\n+        \"\"\"Test that Q objects can be combined when using dict_keys.\"\"\"\n+        empty_dict = {}\n+        q1 = Q(x__in=empty_dict.keys())\n+        q2 = Q(y=1)\n+        q3 = q1 | q2  # Should not raise TypeError\n+        self.assertEqual(q3.children, [('x__in', list(empty_dict.keys())), ('y', 1)])\n+        \n+        # Test empty Q combination\n+        q4 = Q() | Q(x__in=empty_dict.keys())\n+        self.assertEqual(q4.children, [('x__in', list(empty_dict.keys()))])\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}