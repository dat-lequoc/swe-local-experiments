{
  "instance_id": "astropy__astropy-14995",
  "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..40e4dcf767 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -487,7 +487,7 @@ class NDArithmeticMixin:\n         Calculate the resulting mask.\n \n         This is implemented as the piecewise ``or`` operation if both have a\n-        mask.\n+        mask. If only one operand has a mask, that mask is propagated to the result.\n \n         Parameters\n         ----------\n@@ -512,19 +512,21 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n-        # If only one mask is present we need not bother about any type checks\n-        if (\n-            self.mask is None and operand is not None and operand.mask is None\n-        ) or handle_mask is None:\n+        # If neither has a mask or handle_mask is None, return None\n+        if ((self.mask is None and operand is not None and operand.mask is None) \n+                or handle_mask is None):\n             return None\n-        elif self.mask is None and operand is not None:\n-            # Make a copy so there is no reference in the result.\n+            \n+        # If only one operand has a mask, return a copy of that mask\n+        if self.mask is None and operand is not None:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n-        else:\n-            # Now lets calculate the resulting mask (operation enforces copy)\n-            return handle_mask(self.mask, operand.mask, **kwds)\n+        elif operand.mask is None:\n+            return deepcopy(self.mask)\n+            \n+        # Both have masks, apply the handle_mask operation\n+        return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n         \"\"\"\n@@ -747,4 +749,4 @@ class NDArithmeticMixin:\n             )\n \n         # Return a new class based on the result\n-        return cls(result, **init_kwds)\n+        return cls(result, **init_kwds)\n\\ No newline at end of file\ndiff --git a/astropy/nddata/tests/test_nddata.py b/astropy/nddata/tests/test_nddata.py\nindex 033b555fa0..2c977ce140 100644\n--- a/astropy/nddata/tests/test_nddata.py\n+++ b/astropy/nddata/tests/test_nddata.py\n@@ -214,6 +214,35 @@ def test_nddata_init_data_masked_quantity():\n     np.testing.assert_array_equal(nd.mask, np.array(m))\n \n \n+def test_mask_propagation_with_none():\n+    \"\"\"Test mask propagation when one operand has no mask.\"\"\"\n+    from astropy.nddata import NDDataRef\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+    \n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+    \n+    # Test no mask * no mask\n+    result1 = nref_nomask.multiply(1., handle_mask=np.bitwise_or)\n+    assert result1.mask is None\n+    \n+    # Test no mask * no mask (two NDDataRef)\n+    result2 = nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+    assert result2.mask is None\n+    \n+    # Test mask * no mask (scalar)\n+    result3 = nref_mask.multiply(1., handle_mask=np.bitwise_or)\n+    assert_array_equal(result3.mask, mask)\n+    \n+    # Test mask * mask\n+    result4 = nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or)\n+    assert_array_equal(result4.mask, mask)\n+    \n+    # Test mask * no mask (NDDataRef)\n+    result5 = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or)\n+    assert_array_equal(result5.mask, mask)\n+\n def test_nddata_init_data_nddata():\n     nd1 = NDData(np.array([1]))\n     nd2 = NDData(nd1)\n@@ -706,4 +735,4 @@ def test_collapse(mask, unit, propagate_uncertainties, operation_ignores_mask):\n             # min/max data value. We've created the uncertainties to have the same value\n             # as the data array, so we can just check for equality:\n             if method in ext_methods and propagate_uncertainties:\n-                assert np.ma.all(np.ma.equal(astropy_method, nddata_method))\n+                assert np.ma.all(np.ma.equal(astropy_method, nddata_method))\n\\ No newline at end of file\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 15bb49f22b..dc9c3c5f37 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,5 +1,5 @@\n [build-system]\n-requires = [\"setuptools\",\n+requires = [\"setuptools==68.0.0\",\n             \"setuptools_scm>=6.2\",\n             \"cython==0.29.34\",\n             \"oldest-supported-numpy\",\n",
  "model_name_or_path": "KortixAI"
}