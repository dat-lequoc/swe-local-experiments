{
  "instance_id": "matplotlib__matplotlib-25311",
  "model_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..26abccdda0 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -33,6 +33,9 @@ from matplotlib.artist import Artist, allow_rasterization\n from matplotlib.cbook import silent_list\n from matplotlib.font_manager import FontProperties\n from matplotlib.lines import Line2D\n+from matplotlib import patches as mpatches\n+from matplotlib import patches as mpatches\n+from matplotlib import patches as mpatches\n from matplotlib.patches import (Patch, Rectangle, Shadow, FancyBboxPatch,\n                                 StepPatch)\n from matplotlib.collections import (\n@@ -72,6 +75,101 @@ class DraggableLegend(DraggableOffsetBox):\n         self._update = update\n \n         super().__init__(legend, legend._legend_box, use_blit=use_blit)\n+        \n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {'legend': self.legend,\n+                'use_blit': self._use_blit,\n+                'update': self._update}\n+        return state\n+        \n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        self.legend = state['legend']\n+        self._use_blit = state['use_blit']\n+        self._update = state['update']\n+        \n+        # Ensure legend is properly initialized\n+        if not hasattr(self.legend, '_legend_box'):\n+            handles = self.legend.legend_handles\n+            labels = [t.get_text() for t in self.legend.texts]\n+            self.legend._init_legend_box(handles, labels)\n+            \n+        # Reinitialize the parent class\n+        super().__init__(self.legend, self.legend._legend_box,\n+                        use_blit=self._use_blit)\n+        \n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {'legend': self.legend,\n+                'use_blit': self._use_blit,\n+                'update': self._update}\n+        return state\n+        \n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        self.legend = state['legend']\n+        self._use_blit = state['use_blit']\n+        self._update = state['update']\n+        \n+        # Ensure legend is properly initialized\n+        if not hasattr(self.legend, '_legend_box'):\n+            handles = self.legend.legend_handles\n+            labels = [t.get_text() for t in self.legend.texts]\n+            self.legend._init_legend_box(handles, labels)\n+            \n+        # Reinitialize the parent class\n+        super().__init__(self.legend, self.legend._legend_box,\n+                        use_blit=self._use_blit)\n+        # The canvas and event handlers will be reconnected when the figure is redrawn\n+        \n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {'legend': self.legend,\n+                'use_blit': self._use_blit,\n+                'update': self._update}\n+        return state\n+        \n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        self.legend = state['legend']\n+        self._use_blit = state['use_blit']\n+        self._update = state['update']\n+        \n+        # Ensure legend is properly initialized\n+        if not hasattr(self.legend, '_legend_box'):\n+            handles = self.legend.legend_handles\n+            labels = [t.get_text() for t in self.legend.texts]\n+            self.legend._init_legend_box(handles, labels)\n+            \n+        # Reinitialize the parent class\n+        super().__init__(self.legend, self.legend._legend_box,\n+                        use_blit=self._use_blit)\n+        # The canvas and event handlers will be reconnected when the figure is redrawn\n+        \n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {'legend': self.legend,\n+                'use_blit': self._use_blit,\n+                'update': self._update}\n+        return state\n+        \n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        self.legend = state['legend']\n+        self._use_blit = state['use_blit']\n+        self._update = state['update']\n+        \n+        # Ensure legend is properly initialized\n+        if not hasattr(self.legend, '_legend_box'):\n+            handles = self.legend.legend_handles\n+            labels = [t.get_text() for t in self.legend.texts]\n+            self.legend._init_legend_box(handles, labels)\n+            \n+        # Reinitialize the parent class\n+        super().__init__(self.legend, self.legend._legend_box,\n+                        use_blit=self._use_blit)\n+        # The canvas and event handlers will be reconnected when the figure is redrawn\n \n     def finalize_offset(self):\n         if self._update == \"loc\":\n@@ -335,6 +433,386 @@ class Legend(Artist):\n     codes = {'best': 0, **AnchoredOffsetbox.codes}\n     zorder = 5\n \n+    def get_markerfirst(self):\n+        \"\"\"Return whether marker is plotted first in legend.\"\"\"\n+        return getattr(self, '_markerfirst', True)\n+\n+    def set_markerfirst(self, first):\n+        \"\"\"Set whether marker is plotted first in legend.\"\"\"\n+        self._markerfirst = first\n+        self.stale = True\n+\n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {\n+            'parent': self.parent,\n+            'handles': self.legend_handles,\n+            'texts': [t.get_text() for t in self.texts],\n+            '_loc': self._loc,\n+            'numpoints': self.numpoints,\n+            'markerscale': self.markerscale,\n+            '_markerfirst': getattr(self, '_markerfirst', True),\n+            'scatterpoints': self.scatterpoints,\n+            'scatteryoffsets': self._scatteryoffsets,\n+            'prop': self.prop,\n+            'fontsize': self._fontsize,\n+            'labelcolor': None,  # Will be restored from texts\n+            'borderpad': self.borderpad,\n+            'labelspacing': self.labelspacing,\n+            'handlelength': self.handlelength,\n+            'handleheight': self.handleheight,\n+            'handletextpad': self.handletextpad,\n+            'borderaxespad': self.borderaxespad,\n+            'columnspacing': self.columnspacing,\n+            'ncols': self._ncols,\n+            'mode': self._mode,\n+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,\n+            'shadow': self.shadow,\n+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',\n+            'framealpha': self.get_frame().get_alpha(),\n+            'edgecolor': self.get_frame().get_edgecolor(),\n+            'facecolor': self.get_frame().get_facecolor(),\n+            'bbox_to_anchor': self._bbox_to_anchor,\n+            'bbox_transform': self.get_bbox_to_anchor()._transform,\n+            'alignment': self._alignment,\n+            'draggable': hasattr(self, '_draggable') and self._draggable is not None\n+        }\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        # Initialize with basic state\n+        self.__init__(state['parent'], state['handles'], state['texts'],\n+                     numpoints=state['numpoints'],\n+                     markerscale=state['markerscale'],\n+                     markerfirst=state['_markerfirst'],\n+                     scatterpoints=state['scatterpoints'],\n+                     scatteryoffsets=state['scatteryoffsets'],\n+                     prop=state['prop'],\n+                     fontsize=state['fontsize'],\n+                     labelcolor=state['labelcolor'],\n+                     borderpad=state['borderpad'],\n+                     labelspacing=state['labelspacing'],\n+                     handlelength=state['handlelength'],\n+                     handleheight=state['handleheight'],\n+                     handletextpad=state['handletextpad'],\n+                     borderaxespad=state['borderaxespad'],\n+                     columnspacing=state['columnspacing'],\n+                     ncols=state['ncols'],\n+                     mode=state['mode'],\n+                     fancybox=state['fancybox'],\n+                     shadow=state['shadow'],\n+                     title=state['title'],\n+                     framealpha=state['framealpha'],\n+                     edgecolor=state['edgecolor'],\n+                     facecolor=state['facecolor'],\n+                     bbox_to_anchor=state['bbox_to_anchor'],\n+                     bbox_transform=state['bbox_transform'],\n+                     alignment=state['alignment'])\n+\n+        # Restore additional state\n+        self._loc = state['_loc']\n+        self._markerfirst = state['_markerfirst']\n+        \n+        # Ensure legend box is properly initialized\n+        if not hasattr(self, '_legend_box'):\n+            self._init_legend_box(state['handles'], state['texts'])\n+        \n+        # Restore figure reference\n+        if hasattr(self.parent, 'figure'):\n+            self.set_figure(self.parent.figure)\n+        elif hasattr(self.parent, 'get_figure'):\n+            self.set_figure(self.parent.get_figure())\n+            \n+        # Restore draggable state if needed\n+        if state.get('draggable', False):\n+            self.set_draggable(True)\n+\n+    def get_markerfirst(self):\n+        \"\"\"Return whether marker is plotted first in legend.\"\"\"\n+        return getattr(self, '_markerfirst', True)\n+\n+    def set_markerfirst(self, first):\n+        \"\"\"Set whether marker is plotted first in legend.\"\"\"\n+        self._markerfirst = first\n+        self.stale = True\n+\n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {\n+            'parent': self.parent,\n+            'handles': self.legend_handles,\n+            'texts': [t.get_text() for t in self.texts],\n+            '_loc': self._loc,\n+            'numpoints': self.numpoints,\n+            'markerscale': self.markerscale,\n+            '_markerfirst': getattr(self, '_markerfirst', True),\n+            'scatterpoints': self.scatterpoints,\n+            'scatteryoffsets': self._scatteryoffsets,\n+            'prop': self.prop,\n+            'fontsize': self._fontsize,\n+            'labelcolor': None,  # Will be restored from texts\n+            'borderpad': self.borderpad,\n+            'labelspacing': self.labelspacing,\n+            'handlelength': self.handlelength,\n+            'handleheight': self.handleheight,\n+            'handletextpad': self.handletextpad,\n+            'borderaxespad': self.borderaxespad,\n+            'columnspacing': self.columnspacing,\n+            'ncols': self._ncols,\n+            'mode': self._mode,\n+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,\n+            'shadow': self.shadow,\n+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',\n+            'framealpha': self.get_frame().get_alpha(),\n+            'edgecolor': self.get_frame().get_edgecolor(),\n+            'facecolor': self.get_frame().get_facecolor(),\n+            'bbox_to_anchor': self._bbox_to_anchor,\n+            'bbox_transform': self.get_bbox_to_anchor()._transform,\n+            'alignment': self._alignment,\n+            'draggable': hasattr(self, '_draggable') and self._draggable is not None\n+        }\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        # Initialize with basic state\n+        self.__init__(state['parent'], state['handles'], state['texts'],\n+                     numpoints=state['numpoints'],\n+                     markerscale=state['markerscale'],\n+                     markerfirst=state['_markerfirst'],\n+                     scatterpoints=state['scatterpoints'],\n+                     scatteryoffsets=state['scatteryoffsets'],\n+                     prop=state['prop'],\n+                     fontsize=state['fontsize'],\n+                     labelcolor=state['labelcolor'],\n+                     borderpad=state['borderpad'],\n+                     labelspacing=state['labelspacing'],\n+                     handlelength=state['handlelength'],\n+                     handleheight=state['handleheight'],\n+                     handletextpad=state['handletextpad'],\n+                     borderaxespad=state['borderaxespad'],\n+                     columnspacing=state['columnspacing'],\n+                     ncols=state['ncols'],\n+                     mode=state['mode'],\n+                     fancybox=state['fancybox'],\n+                     shadow=state['shadow'],\n+                     title=state['title'],\n+                     framealpha=state['framealpha'],\n+                     edgecolor=state['edgecolor'],\n+                     facecolor=state['facecolor'],\n+                     bbox_to_anchor=state['bbox_to_anchor'],\n+                     bbox_transform=state['bbox_transform'],\n+                     alignment=state['alignment'])\n+\n+        # Restore additional state\n+        self._loc = state['_loc']\n+        self._markerfirst = state['_markerfirst']\n+        \n+        # Ensure legend box is properly initialized\n+        if not hasattr(self, '_legend_box'):\n+            self._init_legend_box(state['handles'], state['texts'])\n+        \n+        # Restore figure reference\n+        if hasattr(self.parent, 'figure'):\n+            self.set_figure(self.parent.figure)\n+        elif hasattr(self.parent, 'get_figure'):\n+            self.set_figure(self.parent.get_figure())\n+            \n+        # Restore draggable state if needed\n+        if state.get('draggable', False):\n+            self.set_draggable(True)\n+\n+    def get_markerfirst(self):\n+        \"\"\"Return whether marker is plotted first in legend.\"\"\"\n+        return getattr(self, '_markerfirst', True)\n+\n+    def set_markerfirst(self, first):\n+        \"\"\"Set whether marker is plotted first in legend.\"\"\"\n+        self._markerfirst = first\n+        self.stale = True\n+\n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {\n+            'parent': self.parent,\n+            'handles': self.legend_handles,\n+            'texts': [t.get_text() for t in self.texts],\n+            '_loc': self._loc,\n+            'numpoints': self.numpoints,\n+            'markerscale': self.markerscale,\n+            '_markerfirst': getattr(self, '_markerfirst', True),\n+            'scatterpoints': self.scatterpoints,\n+            'scatteryoffsets': self._scatteryoffsets,\n+            'prop': self.prop,\n+            'fontsize': self._fontsize,\n+            'labelcolor': None,  # Will be restored from texts\n+            'borderpad': self.borderpad,\n+            'labelspacing': self.labelspacing,\n+            'handlelength': self.handlelength,\n+            'handleheight': self.handleheight,\n+            'handletextpad': self.handletextpad,\n+            'borderaxespad': self.borderaxespad,\n+            'columnspacing': self.columnspacing,\n+            'ncols': self._ncols,\n+            'mode': self._mode,\n+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,\n+            'shadow': self.shadow,\n+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',\n+            'framealpha': self.get_frame().get_alpha(),\n+            'edgecolor': self.get_frame().get_edgecolor(),\n+            'facecolor': self.get_frame().get_facecolor(),\n+            'bbox_to_anchor': self._bbox_to_anchor,\n+            'bbox_transform': self.get_bbox_to_anchor()._transform,\n+            'alignment': self._alignment,\n+            'draggable': hasattr(self, '_draggable') and self._draggable is not None\n+        }\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        # Initialize with basic state\n+        self.__init__(state['parent'], state['handles'], state['texts'],\n+                     numpoints=state['numpoints'],\n+                     markerscale=state['markerscale'],\n+                     markerfirst=state['_markerfirst'],\n+                     scatterpoints=state['scatterpoints'],\n+                     scatteryoffsets=state['scatteryoffsets'],\n+                     prop=state['prop'],\n+                     fontsize=state['fontsize'],\n+                     labelcolor=state['labelcolor'],\n+                     borderpad=state['borderpad'],\n+                     labelspacing=state['labelspacing'],\n+                     handlelength=state['handlelength'],\n+                     handleheight=state['handleheight'],\n+                     handletextpad=state['handletextpad'],\n+                     borderaxespad=state['borderaxespad'],\n+                     columnspacing=state['columnspacing'],\n+                     ncols=state['ncols'],\n+                     mode=state['mode'],\n+                     fancybox=state['fancybox'],\n+                     shadow=state['shadow'],\n+                     title=state['title'],\n+                     framealpha=state['framealpha'],\n+                     edgecolor=state['edgecolor'],\n+                     facecolor=state['facecolor'],\n+                     bbox_to_anchor=state['bbox_to_anchor'],\n+                     bbox_transform=state['bbox_transform'],\n+                     alignment=state['alignment'])\n+\n+        # Restore additional state\n+        self._loc = state['_loc']\n+        self._markerfirst = state['_markerfirst']\n+        \n+        # Ensure legend box is properly initialized\n+        if not hasattr(self, '_legend_box'):\n+            self._init_legend_box(state['handles'], state['texts'])\n+        \n+        # Restore figure reference\n+        if hasattr(self.parent, 'figure'):\n+            self.set_figure(self.parent.figure)\n+        elif hasattr(self.parent, 'get_figure'):\n+            self.set_figure(self.parent.get_figure())\n+            \n+        # Restore draggable state if needed\n+        if state.get('draggable', False):\n+            self.set_draggable(True)\n+\n+    def get_markerfirst(self):\n+        \"\"\"Return whether marker is plotted first in legend.\"\"\"\n+        return getattr(self, '_markerfirst', True)\n+\n+    def set_markerfirst(self, first):\n+        \"\"\"Set whether marker is plotted first in legend.\"\"\"\n+        self._markerfirst = first\n+        self.stale = True\n+\n+    def __getstate__(self):\n+        \"\"\"Get picklable state.\"\"\"\n+        state = {\n+            'parent': self.parent,\n+            'handles': self.legend_handles,\n+            'texts': [t.get_text() for t in self.texts],\n+            '_loc': self._loc,\n+            'numpoints': self.numpoints,\n+            'markerscale': self.markerscale,\n+            '_markerfirst': getattr(self, '_markerfirst', True),\n+            'scatterpoints': self.scatterpoints,\n+            'scatteryoffsets': self._scatteryoffsets,\n+            'prop': self.prop,\n+            'fontsize': self._fontsize,\n+            'labelcolor': None,  # Will be restored from texts\n+            'borderpad': self.borderpad,\n+            'labelspacing': self.labelspacing,\n+            'handlelength': self.handlelength,\n+            'handleheight': self.handleheight,\n+            'handletextpad': self.handletextpad,\n+            'borderaxespad': self.borderaxespad,\n+            'columnspacing': self.columnspacing,\n+            'ncols': self._ncols,\n+            'mode': self._mode,\n+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,\n+            'shadow': self.shadow,\n+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',\n+            'framealpha': self.get_frame().get_alpha(),\n+            'edgecolor': self.get_frame().get_edgecolor(),\n+            'facecolor': self.get_frame().get_facecolor(),\n+            'bbox_to_anchor': self._bbox_to_anchor,\n+            'bbox_transform': self.get_bbox_to_anchor()._transform,\n+            'alignment': self._alignment,\n+            'draggable': hasattr(self, '_draggable') and self._draggable is not None\n+        }\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore from pickled state.\"\"\"\n+        # Initialize with basic state\n+        self.__init__(state['parent'], state['handles'], state['texts'],\n+                     numpoints=state['numpoints'],\n+                     markerscale=state['markerscale'],\n+                     markerfirst=state['_markerfirst'],\n+                     scatterpoints=state['scatterpoints'],\n+                     scatteryoffsets=state['scatteryoffsets'],\n+                     prop=state['prop'],\n+                     fontsize=state['fontsize'],\n+                     labelcolor=state['labelcolor'],\n+                     borderpad=state['borderpad'],\n+                     labelspacing=state['labelspacing'],\n+                     handlelength=state['handlelength'],\n+                     handleheight=state['handleheight'],\n+                     handletextpad=state['handletextpad'],\n+                     borderaxespad=state['borderaxespad'],\n+                     columnspacing=state['columnspacing'],\n+                     ncols=state['ncols'],\n+                     mode=state['mode'],\n+                     fancybox=state['fancybox'],\n+                     shadow=state['shadow'],\n+                     title=state['title'],\n+                     framealpha=state['framealpha'],\n+                     edgecolor=state['edgecolor'],\n+                     facecolor=state['facecolor'],\n+                     bbox_to_anchor=state['bbox_to_anchor'],\n+                     bbox_transform=state['bbox_transform'],\n+                     alignment=state['alignment'])\n+\n+        # Restore additional state\n+        self._loc = state['_loc']\n+        self._markerfirst = state['_markerfirst']\n+        \n+        # Ensure legend box is properly initialized\n+        if not hasattr(self, '_legend_box'):\n+            self._init_legend_box(state['handles'], state['texts'])\n+        \n+        # Restore figure reference\n+        if hasattr(self.parent, 'figure'):\n+            self.set_figure(self.parent.figure)\n+        elif hasattr(self.parent, 'get_figure'):\n+            self.set_figure(self.parent.get_figure())\n+            \n+        # Restore draggable state if needed\n+        if state.get('draggable', False):\n+            self.set_draggable(True)\n+\n     def __str__(self):\n         return \"Legend\"\n \n@@ -1352,4 +1830,4 @@ def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):\n     else:\n         raise TypeError('Invalid arguments to legend.')\n \n-    return handles, labels, extra_args, kwargs\n+    return handles, labels, extra_args, kwargs\n\\ No newline at end of file\ndiff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex ec6bdcc2fe..493efc079f 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -282,3 +282,29 @@ def test_dynamic_norm():\n def test_vertexselector():\n     line, = plt.plot([0, 1], picker=True)\n     pickle.loads(pickle.dumps(VertexSelector(line)))\n+\n+def test_draggable_legend():\n+    \"\"\"Test pickling of figure with draggable legend.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.plot([1, 2, 3], label='test')\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+    # Test pickling the figure\n+    fig_unpickled = pickle.loads(pickle.dumps(fig))\n+    # Verify the legend is still draggable\n+    assert fig_unpickled.axes[0].get_legend().get_draggable()\n+    plt.close(fig)\n+    plt.close(fig_unpickled)\n+\n+def test_draggable_legend():\n+    \"\"\"Test pickling of figure with draggable legend.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.plot([1, 2, 3], label='test')\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+    # Test pickling the figure\n+    fig_unpickled = pickle.loads(pickle.dumps(fig))\n+    # Verify the legend is still draggable\n+    assert fig_unpickled.axes[0].get_legend().get_draggable()\n+    plt.close(fig)\n+    plt.close(fig_unpickled)\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}