{
  "instance_id": "django__django-11001",
  "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39262..2b9e40053d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,7 +353,9 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize SQL to handle multiline expressions\n+            sql_normalized = ' '.join(sql.split())\n+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\n@@ -366,7 +368,9 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                # Normalize SQL to handle multiline expressions\n+            sql_normalized = ' '.join(sql.split())\n+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select\n@@ -1504,4 +1508,4 @@ def cursor_iter(cursor, sentinel, col_count, itersize):\n         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):\n             yield rows if col_count is None else [r[:col_count] for r in rows]\n     finally:\n-        cursor.close()\n+        cursor.close()\n\\ No newline at end of file\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex bce514c0bf..470845be9c 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -622,6 +622,23 @@ class Queries1Tests(TestCase):\n             Tag.objects.filter(parent=self.t1, name='t3').order_by('name'),\n             ['<Tag: t3>']\n         )\n+        \n+    def test_multiline_rawsql_ordering(self):\n+        \"\"\"Test that multiline RawSQL expressions in order_by work correctly.\"\"\"\n+        qs = Tag.objects.all().order_by(\n+            RawSQL('''\n+                CASE WHEN name = 't1'\n+                     THEN 1\n+                     ELSE 2 END''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN name = 't2'\n+                     THEN 1\n+                     ELSE 2 END''', []).desc()\n+        )\n+        # Both order by clauses should be present in the query\n+        sql = str(qs.query)\n+        self.assertIn(\"CASE WHEN name = 't1'\", sql)\n+        self.assertIn(\"CASE WHEN name = 't2'\", sql)\n         self.assertQuerysetEqual(\n             Tag.objects.exclude(parent=self.t1, name='t3').order_by('name'),\n             ['<Tag: t1>', '<Tag: t2>', '<Tag: t4>', '<Tag: t5>']\n@@ -3927,4 +3944,4 @@ class Ticket23622Tests(TestCase):\n             set(Ticket23605A.objects.filter(qx).values_list('pk', flat=True)),\n             set(Ticket23605A.objects.filter(qy).values_list('pk', flat=True))\n         )\n-        self.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])\n+        self.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}