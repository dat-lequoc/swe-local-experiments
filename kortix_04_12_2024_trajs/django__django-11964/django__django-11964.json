{
  "instance_id": "django__django-11964",
  "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..413a8539ac 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2,6 +2,7 @@ import collections.abc\n import copy\n import datetime\n import decimal\n+import enum\n import operator\n import uuid\n import warnings\n@@ -578,6 +579,8 @@ class Field(RegisterLookupMixin):\n         django.core.exceptions.ValidationError if the data can't be converted.\n         Return the converted value. Subclasses should override this.\n         \"\"\"\n+        if value is not None and isinstance(value, enum.Enum):\n+            return value.value\n         return value\n \n     @cached_property\n@@ -792,6 +795,8 @@ class Field(RegisterLookupMixin):\n         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n         if isinstance(value, Promise):\n             value = value._proxy____cast()\n+        if value is not None and isinstance(value, enum.Enum):\n+            value = value.value\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n@@ -858,7 +863,12 @@ class Field(RegisterLookupMixin):\n         Return a string value of this field from the passed obj.\n         This is used by the serialization framework.\n         \"\"\"\n-        return str(self.value_from_object(obj))\n+        value = self.value_from_object(obj)\n+        if value is not None:\n+            if isinstance(value, enum.Enum):\n+                return str(value.value)\n+            return str(value)\n+        return ''\n \n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n@@ -2418,4 +2428,4 @@ class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n         return 'SmallAutoField'\n \n     def rel_db_type(self, connection):\n-        return SmallIntegerField().db_type(connection=connection)\n+        return SmallIntegerField().db_type(connection=connection)\n\\ No newline at end of file\ndiff --git a/tests/model_fields/test_choices.py b/tests/model_fields/test_choices.py\nnew file mode 100644\nindex 0000000000..7e32e14a32\n--- /dev/null\n+++ b/tests/model_fields/test_choices.py\n@@ -0,0 +1,43 @@\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy as _\n+\n+class TextChoiceEnum(models.TextChoices):\n+    A = 'a', _('A')\n+    B = 'b', _('B')\n+\n+class IntegerChoiceEnum(models.IntegerChoices):\n+    ONE = 1, _('One')\n+    TWO = 2, _('Two')\n+\n+class ChoiceModel(models.Model):\n+    text_choice = models.CharField(max_length=1, choices=TextChoiceEnum.choices)\n+    int_choice = models.IntegerField(choices=IntegerChoiceEnum.choices)\n+\n+    class Meta:\n+        app_label = 'model_fields'\n+\n+class ChoicesTests(SimpleTestCase):\n+    def test_text_choice_value_type(self):\n+        instance = ChoiceModel(text_choice=TextChoiceEnum.A)\n+        self.assertIsInstance(instance.text_choice, str)\n+        self.assertEqual(instance.text_choice, 'a')\n+        self.assertEqual(str(instance.text_choice), 'a')\n+\n+    def test_integer_choice_value_type(self):\n+        instance = ChoiceModel(int_choice=IntegerChoiceEnum.ONE)\n+        self.assertIsInstance(instance.int_choice, int)\n+        self.assertEqual(instance.int_choice, 1)\n+        self.assertEqual(str(instance.int_choice), '1')\n+\n+    def test_text_choice_assignment(self):\n+        instance = ChoiceModel()\n+        instance.text_choice = TextChoiceEnum.B\n+        self.assertIsInstance(instance.text_choice, str)\n+        self.assertEqual(instance.text_choice, 'b')\n+\n+    def test_integer_choice_assignment(self):\n+        instance = ChoiceModel()\n+        instance.int_choice = IntegerChoiceEnum.TWO\n+        self.assertIsInstance(instance.int_choice, int)\n+        self.assertEqual(instance.int_choice, 2)\n",
  "model_name_or_path": "KortixAI"
}