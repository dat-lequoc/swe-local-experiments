{
  "instance_id": "django__django-17051",
  "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..b56d9af981 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -6,7 +6,7 @@ from itertools import chain\n \n from django.core.exceptions import EmptyResultSet, FieldError, FullResultSet\n from django.db import DatabaseError, NotSupportedError\n-from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.constants import LOOKUP_SEP, OnConflict\n from django.db.models.expressions import F, OrderBy, RawSQL, Ref, Value\n from django.db.models.functions import Cast, Random\n from django.db.models.lookups import Lookup\n@@ -1761,7 +1761,8 @@ class SQLInsertCompiler(SQLCompiler):\n         # necessary and it should be possible to use placeholders and\n         # expressions in bulk inserts too.\n         can_bulk = (\n-            not self.returning_fields and self.connection.features.has_bulk_insert\n+            (not self.returning_fields or self.query.on_conflict == OnConflict.UPDATE) and\n+            self.connection.features.has_bulk_insert\n         )\n \n         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)\n@@ -2096,4 +2097,4 @@ def cursor_iter(cursor, sentinel, col_count, itersize):\n         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):\n             yield rows if col_count is None else [r[:col_count] for r in rows]\n     finally:\n-        cursor.close()\n+        cursor.close()\n\\ No newline at end of file\ndiff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex aee0cd9996..97f71130cc 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -627,7 +627,7 @@ class BulkCreateTests(TestCase):\n             TwoFields(pk=obj1.pk, f1=3, f2=3, name=\"c\"),\n             TwoFields(pk=obj2.pk, f1=4, f2=4, name=\"d\"),\n         ]\n-        TwoFields.objects.bulk_create(\n+        created = TwoFields.objects.bulk_create(\n             conflicting_objects,\n             update_conflicts=True,\n             unique_fields=[\"pk\"],\n@@ -641,6 +641,24 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+        self.assertEqual(len(created), 2)\n+        self.assertEqual(created[0].pk, obj1.pk)\n+        self.assertEqual(created[1].pk, obj2.pk)\n+\n+    @skipUnlessDBFeature(\"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\")\n+    def test_update_conflicts_returning_fields(self):\n+        \"\"\"Test that bulk_create returns PKs when using update_conflicts.\"\"\"\n+        initial = TwoFields.objects.create(f1=1, f2=1, name=\"initial\")\n+        obj = TwoFields(f1=1, f2=1, name=\"updated\")  # Conflicts with initial\n+        created = TwoFields.objects.bulk_create(\n+            [obj],\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"f1\"],\n+        )\n+        self.assertEqual(len(created), 1)\n+        self.assertEqual(created[0].pk, initial.pk)\n+        self.assertEqual(created[0].name, \"updated\")\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -816,4 +834,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}