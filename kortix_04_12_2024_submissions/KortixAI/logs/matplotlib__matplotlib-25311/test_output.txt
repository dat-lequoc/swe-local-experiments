+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"'
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"'
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh
+++ export GSETTINGS_SCHEMA_DIR_CONDA_BACKUP=
+++ GSETTINGS_SCHEMA_DIR_CONDA_BACKUP=
+++ export GSETTINGS_SCHEMA_DIR=/opt/miniconda3/envs/testbed/share/glib-2.0/schemas
+++ GSETTINGS_SCHEMA_DIR=/opt/miniconda3/envs/testbed/share/glib-2.0/schemas
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh
+++ test -n ''
+++ xml_catalog_files_libxml2=
+++ XML_CATALOG_FILES=
+++ conda_catalog_files=
+++ ifs_libxml2=' 	
'
+++ IFS=' '
+++ rem=/opt/miniconda3/envs/testbed
+++ for pre in ${rem}
+++ test '' = /opt/miniconda3/envs/testbed
+++ conda_catalog_files=/opt/miniconda3/envs/testbed
+++ rem=
+++ IFS=' 	
'
+++ conda_catalog_files='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ export 'XML_CATALOG_FILES=file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ XML_CATALOG_FILES='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ unset conda_catalog_files ifs_libxml2 rem
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   lib/matplotlib/legend.py
	modified:   lib/matplotlib/tests/test_pickle.py

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 430fb1db88843300fb4baae3edc499bbfe073b0c
Merge: ce54a4f092 4554f2159f
Author: Jody Klymak <jklymak@gmail.com>
Date:   Fri Feb 24 11:26:30 2023 -0800

    Merge pull request #25320 from larrybradley/fix-typo

+ git diff 430fb1db88843300fb4baae3edc499bbfe073b0c
diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py
index ff6abdb958..26abccdda0 100644
--- a/lib/matplotlib/legend.py
+++ b/lib/matplotlib/legend.py
@@ -33,6 +33,9 @@ from matplotlib.artist import Artist, allow_rasterization
 from matplotlib.cbook import silent_list
 from matplotlib.font_manager import FontProperties
 from matplotlib.lines import Line2D
+from matplotlib import patches as mpatches
+from matplotlib import patches as mpatches
+from matplotlib import patches as mpatches
 from matplotlib.patches import (Patch, Rectangle, Shadow, FancyBboxPatch,
                                 StepPatch)
 from matplotlib.collections import (
@@ -72,6 +75,101 @@ class DraggableLegend(DraggableOffsetBox):
         self._update = update
 
         super().__init__(legend, legend._legend_box, use_blit=use_blit)
+        
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {'legend': self.legend,
+                'use_blit': self._use_blit,
+                'update': self._update}
+        return state
+        
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        self.legend = state['legend']
+        self._use_blit = state['use_blit']
+        self._update = state['update']
+        
+        # Ensure legend is properly initialized
+        if not hasattr(self.legend, '_legend_box'):
+            handles = self.legend.legend_handles
+            labels = [t.get_text() for t in self.legend.texts]
+            self.legend._init_legend_box(handles, labels)
+            
+        # Reinitialize the parent class
+        super().__init__(self.legend, self.legend._legend_box,
+                        use_blit=self._use_blit)
+        
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {'legend': self.legend,
+                'use_blit': self._use_blit,
+                'update': self._update}
+        return state
+        
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        self.legend = state['legend']
+        self._use_blit = state['use_blit']
+        self._update = state['update']
+        
+        # Ensure legend is properly initialized
+        if not hasattr(self.legend, '_legend_box'):
+            handles = self.legend.legend_handles
+            labels = [t.get_text() for t in self.legend.texts]
+            self.legend._init_legend_box(handles, labels)
+            
+        # Reinitialize the parent class
+        super().__init__(self.legend, self.legend._legend_box,
+                        use_blit=self._use_blit)
+        # The canvas and event handlers will be reconnected when the figure is redrawn
+        
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {'legend': self.legend,
+                'use_blit': self._use_blit,
+                'update': self._update}
+        return state
+        
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        self.legend = state['legend']
+        self._use_blit = state['use_blit']
+        self._update = state['update']
+        
+        # Ensure legend is properly initialized
+        if not hasattr(self.legend, '_legend_box'):
+            handles = self.legend.legend_handles
+            labels = [t.get_text() for t in self.legend.texts]
+            self.legend._init_legend_box(handles, labels)
+            
+        # Reinitialize the parent class
+        super().__init__(self.legend, self.legend._legend_box,
+                        use_blit=self._use_blit)
+        # The canvas and event handlers will be reconnected when the figure is redrawn
+        
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {'legend': self.legend,
+                'use_blit': self._use_blit,
+                'update': self._update}
+        return state
+        
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        self.legend = state['legend']
+        self._use_blit = state['use_blit']
+        self._update = state['update']
+        
+        # Ensure legend is properly initialized
+        if not hasattr(self.legend, '_legend_box'):
+            handles = self.legend.legend_handles
+            labels = [t.get_text() for t in self.legend.texts]
+            self.legend._init_legend_box(handles, labels)
+            
+        # Reinitialize the parent class
+        super().__init__(self.legend, self.legend._legend_box,
+                        use_blit=self._use_blit)
+        # The canvas and event handlers will be reconnected when the figure is redrawn
 
     def finalize_offset(self):
         if self._update == "loc":
@@ -335,6 +433,386 @@ class Legend(Artist):
     codes = {'best': 0, **AnchoredOffsetbox.codes}
     zorder = 5
 
+    def get_markerfirst(self):
+        """Return whether marker is plotted first in legend."""
+        return getattr(self, '_markerfirst', True)
+
+    def set_markerfirst(self, first):
+        """Set whether marker is plotted first in legend."""
+        self._markerfirst = first
+        self.stale = True
+
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {
+            'parent': self.parent,
+            'handles': self.legend_handles,
+            'texts': [t.get_text() for t in self.texts],
+            '_loc': self._loc,
+            'numpoints': self.numpoints,
+            'markerscale': self.markerscale,
+            '_markerfirst': getattr(self, '_markerfirst', True),
+            'scatterpoints': self.scatterpoints,
+            'scatteryoffsets': self._scatteryoffsets,
+            'prop': self.prop,
+            'fontsize': self._fontsize,
+            'labelcolor': None,  # Will be restored from texts
+            'borderpad': self.borderpad,
+            'labelspacing': self.labelspacing,
+            'handlelength': self.handlelength,
+            'handleheight': self.handleheight,
+            'handletextpad': self.handletextpad,
+            'borderaxespad': self.borderaxespad,
+            'columnspacing': self.columnspacing,
+            'ncols': self._ncols,
+            'mode': self._mode,
+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,
+            'shadow': self.shadow,
+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',
+            'framealpha': self.get_frame().get_alpha(),
+            'edgecolor': self.get_frame().get_edgecolor(),
+            'facecolor': self.get_frame().get_facecolor(),
+            'bbox_to_anchor': self._bbox_to_anchor,
+            'bbox_transform': self.get_bbox_to_anchor()._transform,
+            'alignment': self._alignment,
+            'draggable': hasattr(self, '_draggable') and self._draggable is not None
+        }
+        return state
+
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        # Initialize with basic state
+        self.__init__(state['parent'], state['handles'], state['texts'],
+                     numpoints=state['numpoints'],
+                     markerscale=state['markerscale'],
+                     markerfirst=state['_markerfirst'],
+                     scatterpoints=state['scatterpoints'],
+                     scatteryoffsets=state['scatteryoffsets'],
+                     prop=state['prop'],
+                     fontsize=state['fontsize'],
+                     labelcolor=state['labelcolor'],
+                     borderpad=state['borderpad'],
+                     labelspacing=state['labelspacing'],
+                     handlelength=state['handlelength'],
+                     handleheight=state['handleheight'],
+                     handletextpad=state['handletextpad'],
+                     borderaxespad=state['borderaxespad'],
+                     columnspacing=state['columnspacing'],
+                     ncols=state['ncols'],
+                     mode=state['mode'],
+                     fancybox=state['fancybox'],
+                     shadow=state['shadow'],
+                     title=state['title'],
+                     framealpha=state['framealpha'],
+                     edgecolor=state['edgecolor'],
+                     facecolor=state['facecolor'],
+                     bbox_to_anchor=state['bbox_to_anchor'],
+                     bbox_transform=state['bbox_transform'],
+                     alignment=state['alignment'])
+
+        # Restore additional state
+        self._loc = state['_loc']
+        self._markerfirst = state['_markerfirst']
+        
+        # Ensure legend box is properly initialized
+        if not hasattr(self, '_legend_box'):
+            self._init_legend_box(state['handles'], state['texts'])
+        
+        # Restore figure reference
+        if hasattr(self.parent, 'figure'):
+            self.set_figure(self.parent.figure)
+        elif hasattr(self.parent, 'get_figure'):
+            self.set_figure(self.parent.get_figure())
+            
+        # Restore draggable state if needed
+        if state.get('draggable', False):
+            self.set_draggable(True)
+
+    def get_markerfirst(self):
+        """Return whether marker is plotted first in legend."""
+        return getattr(self, '_markerfirst', True)
+
+    def set_markerfirst(self, first):
+        """Set whether marker is plotted first in legend."""
+        self._markerfirst = first
+        self.stale = True
+
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {
+            'parent': self.parent,
+            'handles': self.legend_handles,
+            'texts': [t.get_text() for t in self.texts],
+            '_loc': self._loc,
+            'numpoints': self.numpoints,
+            'markerscale': self.markerscale,
+            '_markerfirst': getattr(self, '_markerfirst', True),
+            'scatterpoints': self.scatterpoints,
+            'scatteryoffsets': self._scatteryoffsets,
+            'prop': self.prop,
+            'fontsize': self._fontsize,
+            'labelcolor': None,  # Will be restored from texts
+            'borderpad': self.borderpad,
+            'labelspacing': self.labelspacing,
+            'handlelength': self.handlelength,
+            'handleheight': self.handleheight,
+            'handletextpad': self.handletextpad,
+            'borderaxespad': self.borderaxespad,
+            'columnspacing': self.columnspacing,
+            'ncols': self._ncols,
+            'mode': self._mode,
+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,
+            'shadow': self.shadow,
+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',
+            'framealpha': self.get_frame().get_alpha(),
+            'edgecolor': self.get_frame().get_edgecolor(),
+            'facecolor': self.get_frame().get_facecolor(),
+            'bbox_to_anchor': self._bbox_to_anchor,
+            'bbox_transform': self.get_bbox_to_anchor()._transform,
+            'alignment': self._alignment,
+            'draggable': hasattr(self, '_draggable') and self._draggable is not None
+        }
+        return state
+
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        # Initialize with basic state
+        self.__init__(state['parent'], state['handles'], state['texts'],
+                     numpoints=state['numpoints'],
+                     markerscale=state['markerscale'],
+                     markerfirst=state['_markerfirst'],
+                     scatterpoints=state['scatterpoints'],
+                     scatteryoffsets=state['scatteryoffsets'],
+                     prop=state['prop'],
+                     fontsize=state['fontsize'],
+                     labelcolor=state['labelcolor'],
+                     borderpad=state['borderpad'],
+                     labelspacing=state['labelspacing'],
+                     handlelength=state['handlelength'],
+                     handleheight=state['handleheight'],
+                     handletextpad=state['handletextpad'],
+                     borderaxespad=state['borderaxespad'],
+                     columnspacing=state['columnspacing'],
+                     ncols=state['ncols'],
+                     mode=state['mode'],
+                     fancybox=state['fancybox'],
+                     shadow=state['shadow'],
+                     title=state['title'],
+                     framealpha=state['framealpha'],
+                     edgecolor=state['edgecolor'],
+                     facecolor=state['facecolor'],
+                     bbox_to_anchor=state['bbox_to_anchor'],
+                     bbox_transform=state['bbox_transform'],
+                     alignment=state['alignment'])
+
+        # Restore additional state
+        self._loc = state['_loc']
+        self._markerfirst = state['_markerfirst']
+        
+        # Ensure legend box is properly initialized
+        if not hasattr(self, '_legend_box'):
+            self._init_legend_box(state['handles'], state['texts'])
+        
+        # Restore figure reference
+        if hasattr(self.parent, 'figure'):
+            self.set_figure(self.parent.figure)
+        elif hasattr(self.parent, 'get_figure'):
+            self.set_figure(self.parent.get_figure())
+            
+        # Restore draggable state if needed
+        if state.get('draggable', False):
+            self.set_draggable(True)
+
+    def get_markerfirst(self):
+        """Return whether marker is plotted first in legend."""
+        return getattr(self, '_markerfirst', True)
+
+    def set_markerfirst(self, first):
+        """Set whether marker is plotted first in legend."""
+        self._markerfirst = first
+        self.stale = True
+
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {
+            'parent': self.parent,
+            'handles': self.legend_handles,
+            'texts': [t.get_text() for t in self.texts],
+            '_loc': self._loc,
+            'numpoints': self.numpoints,
+            'markerscale': self.markerscale,
+            '_markerfirst': getattr(self, '_markerfirst', True),
+            'scatterpoints': self.scatterpoints,
+            'scatteryoffsets': self._scatteryoffsets,
+            'prop': self.prop,
+            'fontsize': self._fontsize,
+            'labelcolor': None,  # Will be restored from texts
+            'borderpad': self.borderpad,
+            'labelspacing': self.labelspacing,
+            'handlelength': self.handlelength,
+            'handleheight': self.handleheight,
+            'handletextpad': self.handletextpad,
+            'borderaxespad': self.borderaxespad,
+            'columnspacing': self.columnspacing,
+            'ncols': self._ncols,
+            'mode': self._mode,
+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,
+            'shadow': self.shadow,
+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',
+            'framealpha': self.get_frame().get_alpha(),
+            'edgecolor': self.get_frame().get_edgecolor(),
+            'facecolor': self.get_frame().get_facecolor(),
+            'bbox_to_anchor': self._bbox_to_anchor,
+            'bbox_transform': self.get_bbox_to_anchor()._transform,
+            'alignment': self._alignment,
+            'draggable': hasattr(self, '_draggable') and self._draggable is not None
+        }
+        return state
+
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        # Initialize with basic state
+        self.__init__(state['parent'], state['handles'], state['texts'],
+                     numpoints=state['numpoints'],
+                     markerscale=state['markerscale'],
+                     markerfirst=state['_markerfirst'],
+                     scatterpoints=state['scatterpoints'],
+                     scatteryoffsets=state['scatteryoffsets'],
+                     prop=state['prop'],
+                     fontsize=state['fontsize'],
+                     labelcolor=state['labelcolor'],
+                     borderpad=state['borderpad'],
+                     labelspacing=state['labelspacing'],
+                     handlelength=state['handlelength'],
+                     handleheight=state['handleheight'],
+                     handletextpad=state['handletextpad'],
+                     borderaxespad=state['borderaxespad'],
+                     columnspacing=state['columnspacing'],
+                     ncols=state['ncols'],
+                     mode=state['mode'],
+                     fancybox=state['fancybox'],
+                     shadow=state['shadow'],
+                     title=state['title'],
+                     framealpha=state['framealpha'],
+                     edgecolor=state['edgecolor'],
+                     facecolor=state['facecolor'],
+                     bbox_to_anchor=state['bbox_to_anchor'],
+                     bbox_transform=state['bbox_transform'],
+                     alignment=state['alignment'])
+
+        # Restore additional state
+        self._loc = state['_loc']
+        self._markerfirst = state['_markerfirst']
+        
+        # Ensure legend box is properly initialized
+        if not hasattr(self, '_legend_box'):
+            self._init_legend_box(state['handles'], state['texts'])
+        
+        # Restore figure reference
+        if hasattr(self.parent, 'figure'):
+            self.set_figure(self.parent.figure)
+        elif hasattr(self.parent, 'get_figure'):
+            self.set_figure(self.parent.get_figure())
+            
+        # Restore draggable state if needed
+        if state.get('draggable', False):
+            self.set_draggable(True)
+
+    def get_markerfirst(self):
+        """Return whether marker is plotted first in legend."""
+        return getattr(self, '_markerfirst', True)
+
+    def set_markerfirst(self, first):
+        """Set whether marker is plotted first in legend."""
+        self._markerfirst = first
+        self.stale = True
+
+    def __getstate__(self):
+        """Get picklable state."""
+        state = {
+            'parent': self.parent,
+            'handles': self.legend_handles,
+            'texts': [t.get_text() for t in self.texts],
+            '_loc': self._loc,
+            'numpoints': self.numpoints,
+            'markerscale': self.markerscale,
+            '_markerfirst': getattr(self, '_markerfirst', True),
+            'scatterpoints': self.scatterpoints,
+            'scatteryoffsets': self._scatteryoffsets,
+            'prop': self.prop,
+            'fontsize': self._fontsize,
+            'labelcolor': None,  # Will be restored from texts
+            'borderpad': self.borderpad,
+            'labelspacing': self.labelspacing,
+            'handlelength': self.handlelength,
+            'handleheight': self.handleheight,
+            'handletextpad': self.handletextpad,
+            'borderaxespad': self.borderaxespad,
+            'columnspacing': self.columnspacing,
+            'ncols': self._ncols,
+            'mode': self._mode,
+            'fancybox': isinstance(self.legendPatch.get_boxstyle(), mpatches.BoxStyle.Round) if hasattr(self, 'legendPatch') else False,
+            'shadow': self.shadow,
+            'title': self._legend_title_box._text.get_text() if self._legend_title_box else '',
+            'framealpha': self.get_frame().get_alpha(),
+            'edgecolor': self.get_frame().get_edgecolor(),
+            'facecolor': self.get_frame().get_facecolor(),
+            'bbox_to_anchor': self._bbox_to_anchor,
+            'bbox_transform': self.get_bbox_to_anchor()._transform,
+            'alignment': self._alignment,
+            'draggable': hasattr(self, '_draggable') and self._draggable is not None
+        }
+        return state
+
+    def __setstate__(self, state):
+        """Restore from pickled state."""
+        # Initialize with basic state
+        self.__init__(state['parent'], state['handles'], state['texts'],
+                     numpoints=state['numpoints'],
+                     markerscale=state['markerscale'],
+                     markerfirst=state['_markerfirst'],
+                     scatterpoints=state['scatterpoints'],
+                     scatteryoffsets=state['scatteryoffsets'],
+                     prop=state['prop'],
+                     fontsize=state['fontsize'],
+                     labelcolor=state['labelcolor'],
+                     borderpad=state['borderpad'],
+                     labelspacing=state['labelspacing'],
+                     handlelength=state['handlelength'],
+                     handleheight=state['handleheight'],
+                     handletextpad=state['handletextpad'],
+                     borderaxespad=state['borderaxespad'],
+                     columnspacing=state['columnspacing'],
+                     ncols=state['ncols'],
+                     mode=state['mode'],
+                     fancybox=state['fancybox'],
+                     shadow=state['shadow'],
+                     title=state['title'],
+                     framealpha=state['framealpha'],
+                     edgecolor=state['edgecolor'],
+                     facecolor=state['facecolor'],
+                     bbox_to_anchor=state['bbox_to_anchor'],
+                     bbox_transform=state['bbox_transform'],
+                     alignment=state['alignment'])
+
+        # Restore additional state
+        self._loc = state['_loc']
+        self._markerfirst = state['_markerfirst']
+        
+        # Ensure legend box is properly initialized
+        if not hasattr(self, '_legend_box'):
+            self._init_legend_box(state['handles'], state['texts'])
+        
+        # Restore figure reference
+        if hasattr(self.parent, 'figure'):
+            self.set_figure(self.parent.figure)
+        elif hasattr(self.parent, 'get_figure'):
+            self.set_figure(self.parent.get_figure())
+            
+        # Restore draggable state if needed
+        if state.get('draggable', False):
+            self.set_draggable(True)
+
     def __str__(self):
         return "Legend"
 
@@ -1352,4 +1830,4 @@ def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):
     else:
         raise TypeError('Invalid arguments to legend.')
 
-    return handles, labels, extra_args, kwargs
+    return handles, labels, extra_args, kwargs
\ No newline at end of file
diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py
index ec6bdcc2fe..493efc079f 100644
--- a/lib/matplotlib/tests/test_pickle.py
+++ b/lib/matplotlib/tests/test_pickle.py
@@ -282,3 +282,29 @@ def test_dynamic_norm():
 def test_vertexselector():
     line, = plt.plot([0, 1], picker=True)
     pickle.loads(pickle.dumps(VertexSelector(line)))
+
+def test_draggable_legend():
+    """Test pickling of figure with draggable legend."""
+    fig, ax = plt.subplots()
+    ax.plot([1, 2, 3], label='test')
+    leg = ax.legend()
+    leg.set_draggable(True)
+    # Test pickling the figure
+    fig_unpickled = pickle.loads(pickle.dumps(fig))
+    # Verify the legend is still draggable
+    assert fig_unpickled.axes[0].get_legend().get_draggable()
+    plt.close(fig)
+    plt.close(fig_unpickled)
+
+def test_draggable_legend():
+    """Test pickling of figure with draggable legend."""
+    fig, ax = plt.subplots()
+    ax.plot([1, 2, 3], label='test')
+    leg = ax.legend()
+    leg.set_draggable(True)
+    # Test pickling the figure
+    fig_unpickled = pickle.loads(pickle.dumps(fig))
+    # Verify the legend is still draggable
+    assert fig_unpickled.axes[0].get_legend().get_draggable()
+    plt.close(fig)
+    plt.close(fig_unpickled)
\ No newline at end of file
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libglib_deactivate.sh"
PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval '. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libglib_deactivate.sh"
PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libxml2_deactivate.sh
++++ test -n ''
++++ unset XML_CATALOG_FILES
++++ unset xml_catalog_files_libxml2
+++ . /opt/miniconda3/envs/testbed/etc/conda/deactivate.d/libglib_deactivate.sh
++++ export GSETTINGS_SCHEMA_DIR=
++++ GSETTINGS_SCHEMA_DIR=
++++ unset GSETTINGS_SCHEMA_DIR_CONDA_BACKUP
++++ '[' -z ']'
++++ unset GSETTINGS_SCHEMA_DIR
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"'
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\''
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh"
. "/opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh"'
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libglib_activate.sh
+++ export GSETTINGS_SCHEMA_DIR_CONDA_BACKUP=
+++ GSETTINGS_SCHEMA_DIR_CONDA_BACKUP=
+++ export GSETTINGS_SCHEMA_DIR=/opt/miniconda3/envs/testbed/share/glib-2.0/schemas
+++ GSETTINGS_SCHEMA_DIR=/opt/miniconda3/envs/testbed/share/glib-2.0/schemas
++ . /opt/miniconda3/envs/testbed/etc/conda/activate.d/libxml2_activate.sh
+++ test -n ''
+++ xml_catalog_files_libxml2=
+++ XML_CATALOG_FILES=
+++ conda_catalog_files=
+++ ifs_libxml2=' 	
'
+++ IFS=' '
+++ rem=/opt/miniconda3/envs/testbed
+++ for pre in ${rem}
+++ test '' = /opt/miniconda3/envs/testbed
+++ conda_catalog_files=/opt/miniconda3/envs/testbed
+++ rem=
+++ IFS=' 	
'
+++ conda_catalog_files='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ export 'XML_CATALOG_FILES=file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ XML_CATALOG_FILES='file:///opt/miniconda3/envs/testbed/etc/xml/catalog file:///etc/xml/catalog'
+++ unset conda_catalog_files ifs_libxml2 rem
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: contourpy>=1.0.1 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (1.1.0)
Requirement already satisfied: cycler>=0.10 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (0.11.0)
Requirement already satisfied: fonttools>=4.22.0 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (4.42.1)
Requirement already satisfied: kiwisolver>=1.0.1 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (1.4.5)
Requirement already satisfied: numpy>=1.21 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (1.25.2)
Requirement already satisfied: packaging>=20.0 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (23.1)
Requirement already satisfied: pillow>=6.2.0 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (10.0.0)
Requirement already satisfied: pyparsing>=2.3.1 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (3.0.9)
Requirement already satisfied: python-dateutil>=2.7 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (2.8.2)
Requirement already satisfied: setuptools_scm>=7 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (7.1.0)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from python-dateutil>=2.7->matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (1.16.0)
Requirement already satisfied: setuptools in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from setuptools_scm>=7->matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (68.1.2)
Requirement already satisfied: typing-extensions in /opt/miniconda3/envs/testbed/lib/python3.11/site-packages (from setuptools_scm>=7->matplotlib==3.8.0.dev441+g430fb1db88.d20241203) (4.7.1)
Building wheels for collected packages: matplotlib
  Building editable for matplotlib (pyproject.toml): started
  Building editable for matplotlib (pyproject.toml): still running...
  Building editable for matplotlib (pyproject.toml): finished with status 'done'
  Created wheel for matplotlib: filename=matplotlib-3.8.0.dev441+g430fb1db88.d20241203-0.editable-cp311-cp311-linux_x86_64.whl size=23294 sha256=2a557f35de9d51a90bace7dee50904cbdc9f3103810c5e8a51fa2d4b24d055cb
  Stored in directory: /tmp/pip-ephem-wheel-cache-fxbjaz83/wheels/49/5f/4f/01b7d31ea6ddac9643da788242d33e5fd3467d95d17b032c6b
Successfully built matplotlib
Installing collected packages: matplotlib
  Attempting uninstall: matplotlib
    Found existing installation: matplotlib 3.8.0.dev441+g430fb1db88
    Uninstalling matplotlib-3.8.0.dev441+g430fb1db88:
      Successfully uninstalled matplotlib-3.8.0.dev441+g430fb1db88
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
Successfully installed matplotlib-3.8.0.dev441+g430fb1db88.d20241203
+ git checkout 430fb1db88843300fb4baae3edc499bbfe073b0c lib/matplotlib/tests/test_pickle.py
Updated 1 path from 40de1c2661
+ git apply -v -
Checking patch lib/matplotlib/tests/test_pickle.py...
Applied patch lib/matplotlib/tests/test_pickle.py cleanly.
+ pytest -rA lib/matplotlib/tests/test_pickle.py
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0
rootdir: /testbed
configfile: pytest.ini
plugins: timeout-2.3.1, cov-6.0.0, xdist-3.6.1, rerunfailures-15.0
collected 183 items

lib/matplotlib/tests/test_pickle.py .FF................................. [ 19%]
........................................................................ [ 59%]
........................................................................ [ 98%]
...                                                                      [100%]

=================================== FAILURES ===================================
______________________________ test_complete[png] ______________________________

ext = 'png', request = <FixtureRequest for <Function test_complete[png]>>
args = (), kwargs = {}, file_name = 'test_complete[png]'
fig_test = <Figure size 640x480 with 0 Axes>
fig_ref = <Figure size 1000x600 with 10 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_pickle.py:106: in test_complete
    loaded = pickle.loads(pkl)
lib/matplotlib/legend.py:770: in __setstate__
    self.__init__(state['parent'], state['handles'], state['texts'],
lib/matplotlib/_api/deprecation.py:454: in wrapper
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <matplotlib.legend.Legend object at 0x762f3dc8fc10>
parent = <[AttributeError("'Axes' object has no attribute '_label'") raised in repr()] Axes object at 0x762f3dc5ec90>
handles = [<matplotlib.collections.PathCollection object at 0x762f3dc8fd10>]
labels = ['$x^2$'], loc = None, numpoints = 1, markerscale = 1.0
markerfirst = True, reverse = False, scatterpoints = 1
scatteryoffsets = array([0.375])
prop = <matplotlib.font_manager.FontProperties object at 0x762f3dc90c50>
fontsize = 10.0, labelcolor = None, borderpad = 0.4, labelspacing = 0.5
handlelength = 2.0, handleheight = 0.7, handletextpad = 0.8, borderaxespad = 0.5
columnspacing = 2.0, ncols = 1, mode = None, fancybox = True, shadow = False
title = '', title_fontsize = None, framealpha = 0.8
edgecolor = (0.8, 0.8, 0.8, 0.8), facecolor = (1.0, 1.0, 1.0, 0.8)
bbox_to_anchor = None
bbox_transform = <matplotlib.transforms.BboxTransformTo object at 0x762f3df280d0>
frameon = None, handler_map = None, title_fontproperties = None
alignment = 'center'

    @_api.make_keyword_only("3.6", "loc")
    @_docstring.dedent_interpd
    def __init__(
        self, parent, handles, labels,
        loc=None,
        numpoints=None,      # number of points in the legend line
        markerscale=None,    # relative size of legend markers vs. original
        markerfirst=True,    # left/right ordering of legend marker and label
        reverse=False,       # reverse ordering of legend marker and label
        scatterpoints=None,  # number of scatter points
        scatteryoffsets=None,
        prop=None,           # properties for the legend texts
        fontsize=None,       # keyword to set font size directly
        labelcolor=None,     # keyword to set the text color
    
        # spacing & pad defined as a fraction of the font-size
        borderpad=None,      # whitespace inside the legend border
        labelspacing=None,   # vertical space between the legend entries
        handlelength=None,   # length of the legend handles
        handleheight=None,   # height of the legend handles
        handletextpad=None,  # pad between the legend handle and text
        borderaxespad=None,  # pad between the axes and legend border
        columnspacing=None,  # spacing between columns
    
        ncols=1,     # number of columns
        mode=None,  # horizontal distribution of columns: None or "expand"
    
        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam
        shadow=None,
        title=None,           # legend title
        title_fontsize=None,  # legend title font size
        framealpha=None,      # set frame alpha
        edgecolor=None,       # frame patch edgecolor
        facecolor=None,       # frame patch facecolor
    
        bbox_to_anchor=None,  # bbox to which the legend will be anchored
        bbox_transform=None,  # transform for the bbox
        frameon=None,         # draw frame
        handler_map=None,
        title_fontproperties=None,  # properties for the legend title
        alignment="center",       # control the alignment within the legend box
        *,
        ncol=1,  # synonym for ncols (backward compatibility)
        draggable=False  # whether the legend can be dragged with the mouse
    ):
        """
        Parameters
        ----------
        parent : `~matplotlib.axes.Axes` or `.Figure`
            The artist that contains the legend.
    
        handles : list of `.Artist`
            A list of Artists (lines, patches) to be added to the legend.
    
        labels : list of str
            A list of labels to show next to the artists. The length of handles
            and labels should be the same. If they are not, they are truncated
            to the length of the shorter list.
    
        Other Parameters
        ----------------
        %(_legend_kw_doc)s
    
        Attributes
        ----------
        legend_handles
            List of `.Artist` objects added as legend entries.
    
            .. versionadded:: 3.7
    
        Notes
        -----
        Users can specify any arbitrary location for the legend using the
        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a
        `.BboxBase` (or derived there from) or a tuple of 2 or 4 floats.
        See `set_bbox_to_anchor` for more detail.
    
        The legend location can be specified by setting *loc* with a tuple of
        2 floats, which is interpreted as the lower-left corner of the legend
        in the normalized axes coordinate.
        """
        # local import only to avoid circularity
        from matplotlib.axes import Axes
        from matplotlib.figure import FigureBase
    
        super().__init__()
    
        if prop is None:
            if fontsize is not None:
                self.prop = FontProperties(size=fontsize)
            else:
                self.prop = FontProperties(
                    size=mpl.rcParams["legend.fontsize"])
        else:
            self.prop = FontProperties._from_any(prop)
            if isinstance(prop, dict) and "size" not in prop:
                self.prop.set_size(mpl.rcParams["legend.fontsize"])
    
        self._fontsize = self.prop.get_size_in_points()
    
        self.texts = []
        self.legend_handles = []
        self._legend_title_box = None
    
        #: A dictionary with the extra handler mappings for this Legend
        #: instance.
        self._custom_handler_map = handler_map
    
        def val_or_rc(val, rc_name):
            return val if val is not None else mpl.rcParams[rc_name]
    
        self.numpoints = val_or_rc(numpoints, 'legend.numpoints')
        self.markerscale = val_or_rc(markerscale, 'legend.markerscale')
        self.scatterpoints = val_or_rc(scatterpoints, 'legend.scatterpoints')
        self.borderpad = val_or_rc(borderpad, 'legend.borderpad')
        self.labelspacing = val_or_rc(labelspacing, 'legend.labelspacing')
        self.handlelength = val_or_rc(handlelength, 'legend.handlelength')
        self.handleheight = val_or_rc(handleheight, 'legend.handleheight')
        self.handletextpad = val_or_rc(handletextpad, 'legend.handletextpad')
        self.borderaxespad = val_or_rc(borderaxespad, 'legend.borderaxespad')
        self.columnspacing = val_or_rc(columnspacing, 'legend.columnspacing')
        self.shadow = val_or_rc(shadow, 'legend.shadow')
        # trim handles and labels if illegal label...
        _lab, _hand = [], []
        for label, handle in zip(labels, handles):
            if isinstance(label, str) and label.startswith('_'):
                _api.warn_external(f"The label {label!r} of {handle!r} starts "
                                   "with '_'. It is thus excluded from the "
                                   "legend.")
            else:
                _lab.append(label)
                _hand.append(handle)
        labels, handles = _lab, _hand
    
        if reverse:
            labels.reverse()
            handles.reverse()
    
        if len(handles) < 2:
            ncols = 1
        self._ncols = ncols if ncols != 1 else ncol
    
        if self.numpoints <= 0:
            raise ValueError("numpoints must be > 0; it was %d" % numpoints)
    
        # introduce y-offset for handles of the scatter plot
        if scatteryoffsets is None:
            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])
        else:
            self._scatteryoffsets = np.asarray(scatteryoffsets)
        reps = self.scatterpoints // len(self._scatteryoffsets) + 1
        self._scatteryoffsets = np.tile(self._scatteryoffsets,
                                        reps)[:self.scatterpoints]
    
        # _legend_box is a VPacker instance that contains all
        # legend items and will be initialized from _init_legend_box()
        # method.
        self._legend_box = None
    
        if isinstance(parent, Axes):
            self.isaxes = True
            self.axes = parent
>           self.set_figure(parent.figure)
E           AttributeError: 'Axes' object has no attribute 'figure'

lib/matplotlib/legend.py:981: AttributeError
------------------------------ Captured log call -------------------------------
WARNING  matplotlib.legend:legend.py:1808 No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
____________________ test_pickle_load_from_subprocess[png] _____________________

ext = 'png'
request = <FixtureRequest for <Function test_pickle_load_from_subprocess[png]>>
args = ()
kwargs = {'tmp_path': PosixPath('/tmp/pytest-of-root/pytest-0/test_pickle_load_from_subproce0')}
file_name = 'test_pickle_load_from_subprocess[png]'
fig_test = <Figure size 640x480 with 0 Axes>
fig_ref = <Figure size 1000x600 with 10 Axes>, figs = []

    @pytest.mark.parametrize("ext", extensions)
    def wrapper(*args, ext, request, **kwargs):
        if 'ext' in old_sig.parameters:
            kwargs['ext'] = ext
        if 'request' in old_sig.parameters:
            kwargs['request'] = request
    
        file_name = "".join(c for c in request.node.name
                            if c in ALLOWED_CHARS)
        try:
            fig_test = plt.figure("test")
            fig_ref = plt.figure("reference")
            with _collect_new_figures() as figs:
>               func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)

lib/matplotlib/testing/decorators.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/matplotlib/tests/test_pickle.py:139: in test_pickle_load_from_subprocess
    proc = subprocess_run_helper(
lib/matplotlib/testing/__init__.py:132: in subprocess_run_helper
    proc = subprocess_run_for_testing(
lib/matplotlib/testing/__init__.py:101: in subprocess_run_for_testing
    proc = subprocess.run(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['/opt/miniconda3/envs/testbed/bin/python3.11', '-c', 'from matplotlib.tests.test_pickle import _pickle_load_subprocess; _pickle_load_subprocess()'],)
kwargs = {'env': {'CONDA_DEFAULT_ENV': 'testbed', 'CONDA_EXE': '/opt/miniconda3/bin/conda', 'CONDA_PREFIX': '/opt/miniconda3/envs/testbed', 'CONDA_PREFIX_1': '/opt/miniconda3', ...}, 'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/opt/miniconda3/envs/testbed/bin/python3.11', ...>
stdout = ''
stderr = 'Traceback (most recent call last):\n  File "<string>", line 1, in <module>\n  File "/testbed/lib/matplotlib/tests/tes...igure(parent.figure)\n                    ^^^^^^^^^^^^^\nAttributeError: \'Axes\' object has no attribute \'figure\'\n'
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/opt/miniconda3/envs/testbed/bin/python3.11', '-c', 'from matplotlib.tests.test_pickle import _pickle_load_subprocess; _pickle_load_subprocess()']' returned non-zero exit status 1.

/opt/miniconda3/envs/testbed/lib/python3.11/subprocess.py:571: CalledProcessError
------------------------------ Captured log call -------------------------------
WARNING  matplotlib.legend:legend.py:1808 No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED lib/matplotlib/tests/test_pickle.py::test_simple
PASSED lib/matplotlib/tests/test_pickle.py::test_gcf
PASSED lib/matplotlib/tests/test_pickle.py::test_no_pyplot
PASSED lib/matplotlib/tests/test_pickle.py::test_renderer
PASSED lib/matplotlib/tests/test_pickle.py::test_image
PASSED lib/matplotlib/tests/test_pickle.py::test_polar
PASSED lib/matplotlib/tests/test_pickle.py::test_transform
PASSED lib/matplotlib/tests/test_pickle.py::test_rrulewrapper
PASSED lib/matplotlib/tests/test_pickle.py::test_shared
PASSED lib/matplotlib/tests/test_pickle.py::test_inset_and_secondary
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap0]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap1]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap2]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap3]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap4]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap5]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap6]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap7]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap8]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap9]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap10]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap11]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap12]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap13]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap14]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap15]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap16]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap17]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap18]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap19]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap20]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap21]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap22]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap23]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap24]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap25]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap26]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap27]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap28]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap29]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap30]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap31]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap32]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap33]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap34]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap35]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap36]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap37]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap38]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap39]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap40]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap41]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap42]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap43]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap44]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap45]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap46]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap47]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap48]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap49]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap50]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap51]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap52]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap53]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap54]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap55]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap56]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap57]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap58]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap59]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap60]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap61]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap62]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap63]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap64]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap65]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap66]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap67]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap68]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap69]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap70]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap71]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap72]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap73]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap74]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap75]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap76]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap77]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap78]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap79]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap80]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap81]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap82]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap83]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap84]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap85]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap86]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap87]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap88]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap89]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap90]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap91]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap92]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap93]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap94]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap95]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap96]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap97]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap98]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap99]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap100]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap101]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap102]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap103]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap104]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap105]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap106]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap107]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap108]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap109]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap110]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap111]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap112]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap113]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap114]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap115]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap116]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap117]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap118]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap119]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap120]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap121]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap122]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap123]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap124]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap125]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap126]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap127]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap128]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap129]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap130]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap131]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap132]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap133]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap134]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap135]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap136]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap137]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap138]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap139]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap140]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap141]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap142]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap143]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap144]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap145]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap146]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap147]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap148]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap149]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap150]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap151]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap152]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap153]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap154]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap155]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap156]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap157]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap158]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap159]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap160]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap161]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap162]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap163]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap164]
PASSED lib/matplotlib/tests/test_pickle.py::test_cmap[cmap165]
PASSED lib/matplotlib/tests/test_pickle.py::test_unpickle_canvas
PASSED lib/matplotlib/tests/test_pickle.py::test_mpl_toolkits
PASSED lib/matplotlib/tests/test_pickle.py::test_standard_norm
PASSED lib/matplotlib/tests/test_pickle.py::test_dynamic_norm
PASSED lib/matplotlib/tests/test_pickle.py::test_vertexselector
FAILED lib/matplotlib/tests/test_pickle.py::test_complete[png] - AttributeErr...
FAILED lib/matplotlib/tests/test_pickle.py::test_pickle_load_from_subprocess[png]
======================== 2 failed, 181 passed in 7.27s =========================
+ git checkout 430fb1db88843300fb4baae3edc499bbfe073b0c lib/matplotlib/tests/test_pickle.py
Updated 1 path from 40de1c2661
