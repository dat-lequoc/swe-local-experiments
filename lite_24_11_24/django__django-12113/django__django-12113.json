{
  "instance_id": "django__django-12113",
  "model_patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..ad78cb9519 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -202,6 +202,9 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     @async_unsafe\n     def get_new_connection(self, conn_params):\n         conn = Database.connect(**conn_params)\n+        # Configure SQLite for better concurrent access\n+        conn.execute('PRAGMA journal_mode=WAL')  # Use Write-Ahead Logging\n+        conn.execute('PRAGMA busy_timeout=10000')  # Wait up to 10 seconds when database is locked\n         conn.create_function(\"django_date_extract\", 2, _sqlite_datetime_extract)\n         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n         conn.create_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)\ndiff --git a/edge_cases.py b/edge_cases.py\nnew file mode 100644\nindex 0000000000..94f5f65b1d\n--- /dev/null\n+++ b/edge_cases.py\n@@ -0,0 +1,128 @@\n+import os\n+import sqlite3\n+import threading\n+import time\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n+\n+def setup_db(db_path):\n+    conn = sqlite3.connect(db_path)\n+    conn.execute('CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, data TEXT)')\n+    conn.commit()\n+    conn.close()\n+\n+def test_large_transaction(db_path):\n+    \"\"\"Test with a large number of operations in a single transaction\"\"\"\n+    try:\n+        conn = sqlite3.connect(db_path)\n+        conn.execute('PRAGMA journal_mode=WAL')\n+        conn.execute('PRAGMA busy_timeout=10000')\n+        \n+        # Large transaction\n+        conn.execute('BEGIN TRANSACTION')\n+        for i in range(1000):\n+            conn.execute('INSERT INTO test_table (data) VALUES (?)', [f'large_trans_{i}'])\n+        conn.commit()\n+        \n+        count = conn.execute('SELECT COUNT(*) FROM test_table').fetchone()[0]\n+        conn.close()\n+        print(f'Large transaction test: Successfully inserted {count} records')\n+        return True\n+    except sqlite3.OperationalError as e:\n+        print(f'Large transaction test failed: {e}')\n+        return False\n+\n+def test_rapid_connections(db_path):\n+    \"\"\"Test rapidly opening and closing connections\"\"\"\n+    try:\n+        for i in range(50):\n+            conn = sqlite3.connect(db_path)\n+            conn.execute('PRAGMA journal_mode=WAL')\n+            conn.execute('PRAGMA busy_timeout=10000')\n+            conn.execute('INSERT INTO test_table (data) VALUES (?)', [f'rapid_{i}'])\n+            conn.commit()\n+            conn.close()\n+        print('Rapid connections test: Success')\n+        return True\n+    except sqlite3.OperationalError as e:\n+        print(f'Rapid connections test failed: {e}')\n+        return False\n+\n+def test_concurrent_reads_writes(db_path):\n+    \"\"\"Test concurrent reads and writes\"\"\"\n+    def reader():\n+        try:\n+            conn = sqlite3.connect(db_path)\n+            conn.execute('PRAGMA journal_mode=WAL')\n+            conn.execute('PRAGMA busy_timeout=10000')\n+            for _ in range(10):\n+                conn.execute('SELECT COUNT(*) FROM test_table').fetchone()\n+                time.sleep(0.01)\n+            conn.close()\n+            return True\n+        except sqlite3.OperationalError as e:\n+            print(f'Reader failed: {e}')\n+            return False\n+\n+    def writer():\n+        try:\n+            conn = sqlite3.connect(db_path)\n+            conn.execute('PRAGMA journal_mode=WAL')\n+            conn.execute('PRAGMA busy_timeout=10000')\n+            for i in range(10):\n+                conn.execute('INSERT INTO test_table (data) VALUES (?)', [f'concurrent_{i}'])\n+                conn.commit()\n+                time.sleep(0.01)\n+            conn.close()\n+            return True\n+        except sqlite3.OperationalError as e:\n+            print(f'Writer failed: {e}')\n+            return False\n+\n+    with ThreadPoolExecutor(max_workers=10) as executor:\n+        futures = []\n+        for _ in range(5):\n+            futures.append(executor.submit(reader))\n+            futures.append(executor.submit(writer))\n+        \n+        results = [f.result() for f in as_completed(futures)]\n+        success = all(results)\n+        print('Concurrent reads/writes test:', 'Success' if success else 'Failed')\n+        return success\n+\n+def main():\n+    print('Running edge case tests...')\n+    db_path = 'edge_case_test.sqlite3'\n+    \n+    # Clean up any existing test database\n+    if os.path.exists(db_path):\n+        os.remove(db_path)\n+    \n+    # Setup fresh database\n+    setup_db(db_path)\n+    \n+    # Run tests\n+    tests = [\n+        ('Large Transaction Test', lambda: test_large_transaction(db_path)),\n+        ('Rapid Connections Test', lambda: test_rapid_connections(db_path)),\n+        ('Concurrent Reads/Writes Test', lambda: test_concurrent_reads_writes(db_path))\n+    ]\n+    \n+    all_passed = True\n+    for test_name, test_func in tests:\n+        print(f'\\nRunning {test_name}...')\n+        try:\n+            if not test_func():\n+                all_passed = False\n+                print(f'{test_name} failed!')\n+        except Exception as e:\n+            all_passed = False\n+            print(f'{test_name} failed with exception: {e}')\n+    \n+    # Cleanup\n+    if os.path.exists(db_path):\n+        os.remove(db_path)\n+    \n+    print('\\nFinal Result:', 'All tests passed!' if all_passed else 'Some tests failed!')\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..f69da42955\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,66 @@\n+import os\n+import sqlite3\n+import threading\n+import time\n+\n+def setup_db(db_path):\n+    conn = sqlite3.connect(db_path)\n+    conn.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT)')\n+    conn.commit()\n+    conn.close()\n+\n+def write_to_db(db_path, thread_id):\n+    try:\n+        conn = sqlite3.connect(db_path)\n+        # Configure SQLite for better concurrent access\n+        conn.execute('PRAGMA journal_mode=WAL')\n+        conn.execute('PRAGMA busy_timeout=10000')\n+        \n+        # Simulate multiple writes\n+        for i in range(5):\n+            conn.execute('INSERT INTO users (username) VALUES (?)', [f'user_{thread_id}_{i}'])\n+            conn.commit()\n+            time.sleep(0.1)  # Small delay to increase chance of concurrent access\n+        \n+        conn.close()\n+        print(f'Thread {thread_id}: Successfully completed all writes')\n+        return True\n+    except sqlite3.OperationalError as e:\n+        print(f'Thread {thread_id}: Error - {e}')\n+        return False\n+\n+def main():\n+    print('Testing SQLite concurrent access...')\n+    \n+    # Create test databases\n+    db_paths = ['test_default.sqlite3', 'test_other.sqlite3']\n+    for db_path in db_paths:\n+        if os.path.exists(db_path):\n+            os.remove(db_path)\n+        setup_db(db_path)\n+    \n+    # Create threads to simulate concurrent access\n+    threads = []\n+    success = True\n+    \n+    for i in range(4):  # Create 4 threads\n+        for db_path in db_paths:\n+            thread = threading.Thread(target=lambda: success and write_to_db(db_path, i))\n+            threads.append(thread)\n+            thread.start()\n+    \n+    # Wait for all threads to complete\n+    for thread in threads:\n+        thread.join()\n+    \n+    # Verify the results\n+    for db_path in db_paths:\n+        conn = sqlite3.connect(db_path)\n+        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]\n+        print(f'\\nDatabase {db_path}: {count} records written')\n+        conn.close()\n+    \n+    print('\\nTest completed successfully!' if success else '\\nTest failed!')\n+\n+if __name__ == '__main__':\n+    main()\n\\ No newline at end of file\ndiff --git a/test_default.sqlite3 b/test_default.sqlite3\nnew file mode 100644\nindex 0000000000..8b357f2e69\nBinary files /dev/null and b/test_default.sqlite3 differ\ndiff --git a/test_other.sqlite3 b/test_other.sqlite3\nnew file mode 100644\nindex 0000000000..b0c48ba675\nBinary files /dev/null and b/test_other.sqlite3 differ\n",
  "model_name_or_path": "KortixAI"
}