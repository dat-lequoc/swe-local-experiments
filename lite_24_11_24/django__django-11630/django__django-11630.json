{
  "instance_id": "django__django-11630",
  "model_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..65368f949d 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -9,17 +9,30 @@ from django.core.checks import Error, Tags, register\n \n @register(Tags.models)\n def check_all_models(app_configs=None, **kwargs):\n-    db_table_models = defaultdict(list)\n+    from django.db import router\n+\n+    # Group models by database connection\n+    db_models = defaultdict(lambda: defaultdict(list))\n     indexes = defaultdict(list)\n     constraints = defaultdict(list)\n     errors = []\n+    \n     if app_configs is None:\n         models = apps.get_models()\n     else:\n         models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n+\n+    # First pass: collect all models and their database assignments\n+    model_dbs = {}\n     for model in models:\n         if model._meta.managed and not model._meta.proxy:\n-            db_table_models[model._meta.db_table].append(model._meta.label)\n+            # Use the router to determine the database\n+            db = router.db_for_write(model)\n+            if db is None:\n+                db = 'default'\n+            model_dbs[model] = db\n+            db_models[db][model._meta.db_table].append(model._meta.label)\n+\n         if not inspect.ismethod(model.check):\n             errors.append(\n                 Error(\n@@ -31,20 +44,29 @@ def check_all_models(app_configs=None, **kwargs):\n             )\n         else:\n             errors.extend(model.check(**kwargs))\n+        \n         for model_index in model._meta.indexes:\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n-        if len(model_labels) != 1:\n-            errors.append(\n-                Error(\n-                    \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n-                    obj=db_table,\n-                    id='models.E028',\n+    \n+    # Check for table name conflicts within each database\n+    for db, table_models in db_models.items():\n+        for db_table, model_labels in table_models.items():\n+            if len(model_labels) > 1:\n+                # Multiple models sharing the same table in the same database is not allowed\n+                model_list = sorted(model_labels)\n+                errors.append(\n+                    Error(\n+                        \"db_table '%s' is used by multiple models in the same database '%s': %s. \"\n+                        \"Models in the same database must use unique table names.\"\n+                        % (db_table, db or 'default', ', '.join(model_list)),\n+                        obj=db_table,\n+                        id='models.E028',\n+                        hint=\"Ensure models '%s' use different 'db_table' values when they share the same database connection.\" \n+                        % \"' and '\".join(model_list)\n+                    )\n                 )\n-            )\n     for index_name, model_labels in indexes.items():\n         if len(model_labels) > 1:\n             model_labels = set(model_labels)\ndiff --git a/edge_cases.py b/edge_cases.py\nnew file mode 100644\nindex 0000000000..76f1fc22c6\n--- /dev/null\n+++ b/edge_cases.py\n@@ -0,0 +1,108 @@\n+from django.conf import settings\n+from django.core.checks import Error\n+from django.db import models, router\n+\n+# Database router\n+class AppRouter:\n+    \"\"\"\n+    Router that assigns models to databases based on their app_label.\n+    \"\"\"\n+    def db_for_read(self, model, **hints):\n+        if model._meta.app_label in ['app2', 'app3']:\n+            return 'other_db'\n+        return 'default'\n+\n+    def db_for_write(self, model, **hints):\n+        if model._meta.app_label in ['app2', 'app3']:\n+            return 'other_db'\n+        return 'default'\n+\n+    def allow_relation(self, obj1, obj2, **hints):\n+        return True\n+\n+    def allow_migrate(self, db, app_label, model_name=None, **hints):\n+        if app_label in ['app2', 'app3']:\n+            return db == 'other_db'\n+        return db == 'default'\n+\n+# Register the router globally\n+router.routers = [AppRouter()]\n+\n+# Configure Django settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        },\n+        'other_db': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    DATABASE_ROUTERS=['__main__.AppRouter'],\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+)\n+\n+import django\n+django.setup()\n+\n+# Test models\n+class BaseModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'base'\n+        db_table = 'shared_table'\n+\n+class App2Model(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'app2'\n+        db_table = 'shared_table'\n+\n+class App3Model(models.Model):\n+    description = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'app3'\n+        db_table = 'shared_table'  # Same table name in same database as App2Model\n+\n+from django.core.checks import model_checks\n+\n+def test_edge_cases():\n+    print(\"\\nTesting edge cases...\")\n+    \n+    # Get all errors\n+    errors = model_checks.check_all_models()\n+    \n+    # Filter for E028 errors\n+    e028_errors = [e for e in errors if e.id == 'models.E028']\n+    \n+    # Test Case 1: Models in same database with same table name\n+    test1 = any(\n+        'app2.App2Model' in error.msg and 'app3.App3Model' in error.msg \n+        for error in e028_errors\n+    )\n+    print(\"[PASS]\" if test1 else \"[FAIL]\", \n+          \"Detected conflict between models using same table in same database\")\n+\n+    # Test Case 2: No false positives for models in different databases\n+    test2 = not any(\n+        'base.BaseModel' in error.msg and 'app2.App2Model' in error.msg \n+        for error in e028_errors\n+    )\n+    print(\"[PASS]\" if test2 else \"[FAIL]\", \n+          \"No false positives for models in different databases\")\n+\n+    return test1 and test2\n+\n+if __name__ == '__main__':\n+    success = test_edge_cases()\n+    if success:\n+        print(\"\\nAll edge cases passed!\")\n+        exit(0)\n+    else:\n+        print(\"\\nEdge cases failed!\")\n+        exit(1)\n\\ No newline at end of file\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..3e86976c70\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,88 @@\n+from django.conf import settings\n+from django.core.checks import Error\n+from django.db import models\n+from django.test import TestCase\n+\n+# Database router\n+class AppRouter:\n+    def db_for_read(self, model, **hints):\n+        if model._meta.app_label == 'app2':\n+            return 'other_db'\n+        return 'default'\n+\n+    def db_for_write(self, model, **hints):\n+        if model._meta.app_label == 'app2':\n+            return 'other_db'\n+        return 'default'\n+\n+    def allow_relation(self, obj1, obj2, **hints):\n+        return True\n+\n+    def allow_migrate(self, db, app_label, model_name=None, **hints):\n+        if app_label == 'app2':\n+            return db == 'other_db'\n+        return db == 'default'\n+\n+# Configure Django settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        },\n+        'other_db': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    DATABASE_ROUTERS=['__main__.AppRouter'],\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+)\n+\n+import django\n+django.setup()\n+\n+# Test models\n+class BaseModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'base'\n+        db_table = 'shared_table'\n+\n+class App2Model(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'app2'\n+        db_table = 'shared_table'\n+\n+# Run tests\n+from django.core.checks import model_checks\n+\n+def test_table_name_validation():\n+    print(\"\\nTesting table name validation...\")\n+    \n+    # Get all errors\n+    errors = model_checks.check_all_models()\n+    \n+    # Filter for E028 errors\n+    e028_errors = [e for e in errors if e.id == 'models.E028']\n+    \n+    if not e028_errors:\n+        print(\"[PASS] No E028 errors when models use same table name in different databases\")\n+        return True\n+    else:\n+        print(\"[FAIL] Found E028 errors:\")\n+        for error in e028_errors:\n+            print(f\"  - {error.msg}\")\n+        return False\n+\n+if __name__ == '__main__':\n+    success = test_table_name_validation()\n+    if success:\n+        print(\"\\nAll tests passed!\")\n+        exit(0)\n+    else:\n+        print(\"\\nTests failed!\")\n+        exit(1)\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}