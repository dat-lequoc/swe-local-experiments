{
  "instance_id": "django__django-12453",
  "model_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex c50fc90171..5cf1f5b3c2 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -5,7 +5,7 @@ from io import StringIO\n from django.apps import apps\n from django.conf import settings\n from django.core import serializers\n-from django.db import router\n+from django.db import router, transaction\n \n # The prefix to put on the default database name when creating\n # the test database.\n@@ -126,8 +126,9 @@ class BaseDatabaseCreation:\n         the serialize_db_to_string() method.\n         \"\"\"\n         data = StringIO(data)\n-        for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n-            obj.save()\n+        with transaction.atomic(using=self.connection.alias):\n+            for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n+                obj.save()\n \n     def _get_database_display_str(self, verbosity, database_name):\n         \"\"\"\ndiff --git a/edge_cases.py b/edge_cases.py\nnew file mode 100644\nindex 0000000000..d06ffee6af\n--- /dev/null\n+++ b/edge_cases.py\n@@ -0,0 +1,122 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'test_app',\n+        ],\n+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',\n+    )\n+    django.setup()\n+    \n+    # Create the test database tables\n+    from django.core.management import call_command\n+    call_command('migrate', verbosity=0, interactive=False, run_syncdb=True)\n+\n+from django.db import models, transaction, connection, DEFAULT_DB_ALIAS\n+from django.test import TransactionTestCase\n+from django.test.testcases import connections\n+from django.core import serializers\n+from test_app.models import Author, Book\n+\n+class EdgeCaseTests(TransactionTestCase):\n+    serialized_rollback = True\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.connection = connections[DEFAULT_DB_ALIAS]\n+\n+    def test_multiple_books_single_author(self):\n+        \"\"\"Test restoring multiple books linked to the same author.\"\"\"\n+        try:\n+            # Create test data\n+            author = Author.objects.create(name='Multiple Books Author')\n+            books = [\n+                Book.objects.create(title=f'Book {i}', author=author)\n+                for i in range(3)\n+            ]\n+\n+            # Manually serialize test data\n+            test_objects = list(Author.objects.all()) + list(Book.objects.all())\n+            serialized_data = serializers.serialize('json', test_objects)\n+\n+            # Delete all data\n+            Book.objects.all().delete()\n+            Author.objects.all().delete()\n+\n+            # Restore data\n+            self.connection.creation.deserialize_db_from_string(serialized_data)\n+\n+            # Verify restoration\n+            self.assertEqual(Author.objects.count(), 1)\n+            self.assertEqual(Book.objects.count(), 3)\n+            print(\"Multiple books test passed!\")\n+            return True\n+        except Exception as e:\n+            print(f\"Multiple books test failed: {str(e)}\")\n+            return False\n+\n+    def test_circular_dependency(self):\n+        \"\"\"Test handling of circular dependencies in serialization.\"\"\"\n+        try:\n+            # Create test data with specific IDs to force ordering\n+            author1 = Author.objects.create(name='Author 1')\n+            author2 = Author.objects.create(name='Author 2')\n+            book1 = Book.objects.create(title='Book 1', author=author2)\n+            book2 = Book.objects.create(title='Book 2', author=author1)\n+\n+            # Manually serialize test data\n+            test_objects = list(Author.objects.all()) + list(Book.objects.all())\n+            serialized_data = serializers.serialize('json', test_objects)\n+\n+            # Delete all data\n+            Book.objects.all().delete()\n+            Author.objects.all().delete()\n+\n+            # Restore data\n+            self.connection.creation.deserialize_db_from_string(serialized_data)\n+\n+            # Verify restoration\n+            self.assertEqual(Author.objects.count(), 2)\n+            self.assertEqual(Book.objects.count(), 2)\n+            print(\"Circular dependency test passed!\")\n+            return True\n+        except Exception as e:\n+            print(f\"Circular dependency test failed: {str(e)}\")\n+            return False\n+\n+if __name__ == '__main__':\n+    try:\n+        # Create and run test instances\n+        test = EdgeCaseTests('test_multiple_books_single_author')\n+        test._pre_setup()\n+        test.setUp()\n+        success1 = test.test_multiple_books_single_author()\n+        test.tearDown()\n+        test._post_teardown()\n+\n+        test = EdgeCaseTests('test_circular_dependency')\n+        test._pre_setup()\n+        test.setUp()\n+        success2 = test.test_circular_dependency()\n+        test.tearDown()\n+        test._post_teardown()\n+\n+        if not (success1 and success2):\n+            exit(1)\n+        print(\"\\nAll edge case tests completed successfully!\")\n+    except Exception as e:\n+        print(f\"\\nTests failed with error: {str(e)}\")\n+        exit(1)\n\\ No newline at end of file\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..d76e44d0d2\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,142 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'test_app',\n+        ],\n+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',\n+    )\n+    django.setup()\n+    \n+    # Create the test database tables\n+    from django.core.management import call_command\n+    call_command('migrate', verbosity=0, interactive=False, run_syncdb=True)\n+\n+from django.db import models, transaction, connection, DEFAULT_DB_ALIAS\n+from django.test import TransactionTestCase\n+from django.test.testcases import connections\n+from django.apps import apps\n+\n+# Import test models\n+from test_app.models import Author, Book\n+\n+def create_tables():\n+    \"\"\"Create the database tables for our models.\"\"\"\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Author)\n+        schema_editor.create_model(Book)\n+\n+class SerializedRollbackTest(TransactionTestCase):\n+    serialized_rollback = True\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        # Create tables only if they don't exist\n+        try:\n+            create_tables()\n+        except Exception as e:\n+            if 'already exists' not in str(e):\n+                raise\n+\n+    def setUp(self):\n+        super().setUp()\n+        # Create test data\n+        self.author = Author.objects.create(name='Test Author')\n+        self.book = Book.objects.create(title='Test Book', author=self.author)\n+        \n+        # Store the serialized database state\n+        self.connection = connections[DEFAULT_DB_ALIAS]\n+        # Manually serialize our test data\n+        from django.core import serializers\n+        test_objects = list(Author.objects.all()) + list(Book.objects.all())\n+        serialized_data = serializers.serialize('json', test_objects)\n+        self.connection._test_serialized_contents = serialized_data\n+\n+    def test_serialized_rollback(self):\n+        \"\"\"Test that serialized rollback correctly restores objects with foreign key relationships.\"\"\"\n+        try:\n+            print(\"\\nInitial state:\")\n+            print(f\"Authors: {Author.objects.count()}\")\n+            print(f\"Books: {Book.objects.count()}\")\n+            \n+            # Verify initial state\n+            self.assertEqual(Author.objects.count(), 1)\n+            self.assertEqual(Book.objects.count(), 1)\n+\n+            # Store serialized data\n+            serialized_data = self.connection._test_serialized_contents\n+            print(\"\\nSerialized data:\", serialized_data)\n+\n+            # Delete all data\n+            Book.objects.all().delete()\n+            Author.objects.all().delete()\n+\n+            print(\"\\nAfter deletion:\")\n+            print(f\"Authors: {Author.objects.count()}\")\n+            print(f\"Books: {Book.objects.count()}\")\n+\n+            # Verify data is deleted\n+            self.assertEqual(Author.objects.count(), 0)\n+            self.assertEqual(Book.objects.count(), 0)\n+\n+            # Restore the serialized data\n+            print(\"\\nRestoring data...\")\n+            self.connection.creation.deserialize_db_from_string(serialized_data)\n+\n+            print(\"\\nAfter restoration:\")\n+            print(f\"Authors: {Author.objects.count()}\")\n+            print(f\"Books: {Book.objects.count()}\")\n+\n+            # Verify data is restored correctly\n+            self.assertEqual(Author.objects.count(), 1, \"Author object was not restored\")\n+            self.assertEqual(Book.objects.count(), 1, \"Book object was not restored\")\n+            \n+            restored_book = Book.objects.first()\n+            if restored_book:\n+                print(f\"\\nRestored book: {restored_book.title}\")\n+                print(f\"Restored author: {restored_book.author.name}\")\n+            else:\n+                print(\"\\nNo book was restored\")\n+\n+            print(\"Test completed successfully!\")\n+            return True\n+        except Exception as e:\n+            print(f\"Test failed: {str(e)}\")\n+            return False\n+\n+if __name__ == '__main__':\n+    try:\n+        # Create and set up the test instance\n+        test = SerializedRollbackTest('test_serialized_rollback')\n+        test.setUpClass()\n+        test._pre_setup()\n+        test.setUp()\n+        \n+        # Run the test\n+        success = test.test_serialized_rollback()\n+        \n+        # Clean up\n+        test.tearDown()\n+        test._post_teardown()\n+        test.tearDownClass()\n+        \n+        if not success:\n+            exit(1)\n+        print(\"\\nTest completed successfully!\")\n+    except Exception as e:\n+        print(f\"\\nTest failed with error: {str(e)}\")\n+        exit(1)\n\\ No newline at end of file\ndiff --git a/test_app/__init__.py b/test_app/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_app/models.py b/test_app/models.py\nnew file mode 100644\nindex 0000000000..e3de8b9bd0\n--- /dev/null\n+++ b/test_app/models.py\n@@ -0,0 +1,8 @@\n+from django.db import models\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}