{
  "instance_id": "django__django-12284",
  "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..b48717eb1c 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -271,11 +271,46 @@ class ModelBase(type):\n \n                 # Add fields from abstract base class if it wasn't overridden.\n                 for field in parent_fields:\n-                    if (field.name not in field_names and\n-                            field.name not in new_class.__dict__ and\n-                            field.name not in inherited_attributes):\n+                    field_name = field.name\n+                    # Check if the field is redefined in the child class\n+                    if field_name in new_class.__dict__:\n+                        child_field = new_class.__dict__[field_name]\n+                        if hasattr(child_field, 'choices'):\n+                            # Create a new field instance with updated choices\n+                            from django.db.models.fields import CharField\n+                            if isinstance(child_field, CharField):\n+                                choices = None\n+                                if hasattr(new_class, field_name + '_choice'):\n+                                    choices = getattr(new_class, field_name + '_choice')\n+                                elif child_field.choices:\n+                                    choices = child_field.choices\n+                                \n+                                if choices:\n+                                    new_field = CharField(\n+                                        max_length=child_field.max_length,\n+                                        choices=choices,\n+                                        default=child_field.default if child_field.default != NOT_PROVIDED else None,\n+                                        null=child_field.null,\n+                                        blank=child_field.blank,\n+                                        db_column=child_field.db_column,\n+                                        db_index=child_field.db_index,\n+                                    )\n+                                    new_field.contribute_to_class(new_class, field_name)\n+                                    new_class._meta.local_fields = [f for f in new_class._meta.local_fields if f.name != field_name]\n+                                    new_class._meta.local_fields.append(new_field)\n+                    elif field_name not in field_names and field_name not in inherited_attributes:\n                         new_field = copy.deepcopy(field)\n-                        new_class.add_to_class(field.name, new_field)\n+                        # Update choices if defined in child class\n+                        if hasattr(new_class, field_name + '_choice'):\n+                            choices = getattr(new_class, field_name + '_choice')\n+                            new_field.choices = choices\n+                            if hasattr(new_field, '_choices'):\n+                                new_field._choices = None\n+                            new_field.flatchoices = choices\n+                            # Ensure the field knows about its choices\n+                            if hasattr(new_field, 'set_attributes_from_name'):\n+                                new_field.set_attributes_from_name(field_name)\n+                        new_class.add_to_class(field_name, new_field)\n                         # Replace parent links defined on this base by the new\n                         # field. It will be appropriately resolved if required.\n                         if field.one_to_one:\n@@ -945,9 +980,22 @@ class Model(metaclass=ModelBase):\n \n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+        \n+        # Get choices from the field itself first\n+        choices = None\n+        if field.choices:\n+            choices = field.choices\n+        \n+        # If no choices on field, try class attribute\n+        if not choices and hasattr(self.__class__, field.name + '_choice'):\n+            choices = getattr(self.__class__, field.name + '_choice')\n+        \n+        if not choices:\n+            return force_str(value, strings_only=True)\n+        \n+        # Convert choices to dict and get display value\n+        choices_dict = dict(choices)\n+        return force_str(choices_dict.get(value, value), strings_only=True)\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..7453eb195d\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,47 @@\n+from django.conf import settings\n+from django.db import models\n+\n+# Configure Django settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+)\n+\n+import django\n+django.setup()\n+\n+# Test models\n+class A(models.Model):\n+    foo_choice = [('A', 'output1'), ('B', 'output2')]\n+    field_foo = models.CharField(max_length=254, choices=foo_choice)\n+    class Meta:\n+        abstract = True\n+        app_label = 'testapp'\n+\n+class B(A):\n+    foo_choice = [('A', 'output1'), ('B', 'output2'), ('C', 'output3')]\n+    field_foo = models.CharField(max_length=254, choices=foo_choice)\n+    class Meta:\n+        app_label = 'testapp'\n+\n+def test_choices_inheritance():\n+    b = B()\n+    b.field_foo = 'C'\n+    result = b.get_field_foo_display()\n+    print(f'Test result for value \"C\": {result == \"output3\"} (got \"{result}\", expected \"output3\")')\n+    \n+    b.field_foo = 'A'\n+    result = b.get_field_foo_display()\n+    print(f'Test result for value \"A\": {result == \"output1\"} (got \"{result}\", expected \"output1\")')\n+    \n+    b.field_foo = 'B'\n+    result = b.get_field_foo_display()\n+    print(f'Test result for value \"B\": {result == \"output2\"} (got \"{result}\", expected \"output2\")')\n+\n+if __name__ == '__main__':\n+    test_choices_inheritance()\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}