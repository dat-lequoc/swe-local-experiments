{
  "instance_id": "django__django-11848",
  "model_patch": "diff --git a/django/utils/http.py b/django/utils/http.py\nindex 572cfb4347..d54916aae0 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -155,6 +155,32 @@ def http_date(epoch_seconds=None):\n     return formatdate(epoch_seconds, usegmt=True)\n \n \n+def _convert_two_digit_year(year):\n+    \"\"\"\n+    Convert a two-digit year to a four-digit year following RFC 7231 rules.\n+    \n+    Recipients of a timestamp value in rfc850-date format, which uses a two-digit\n+    year, MUST interpret a timestamp that appears to be more than 50 years in\n+    the future as representing the most recent year in the past that had the\n+    same last two digits.\n+    \"\"\"\n+    if year >= 100:\n+        return year\n+\n+    current_year = datetime.datetime.now().year\n+    two_digit_year = year % 100\n+    current_century = current_year // 100\n+    \n+    # Calculate year in current century\n+    candidate_year = (current_century * 100) + two_digit_year\n+    \n+    # If the candidate year would be more than 50 years in the future,\n+    # use the previous century instead\n+    if candidate_year > current_year + 50:\n+        return ((current_century - 1) * 100) + two_digit_year\n+            \n+    return candidate_year\n+\n def parse_http_date(date):\n     \"\"\"\n     Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n@@ -175,11 +201,7 @@ def parse_http_date(date):\n         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n     try:\n         year = int(m.group('year'))\n-        if year < 100:\n-            if year < 70:\n-                year += 2000\n-            else:\n-                year += 1900\n+        year = _convert_two_digit_year(year)\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..60b969fcfb\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,52 @@\n+import datetime\n+from django.utils.http import parse_http_date\n+\n+def test_parse_http_date():\n+    # Helper function to create test dates\n+    def create_rfc850_date(year, month=11, day=6):\n+        return f\"Sunday, {day:02d}-Nov-{year:02d} 08:49:37 GMT\"\n+\n+    # Get current year for testing\n+    current_year = datetime.datetime.now().year\n+    current_year_2d = current_year % 100\n+    \n+    # Test cases\n+    test_cases = [\n+        # Basic test - date in the past\n+        (create_rfc850_date(94), 1994),\n+        \n+        # Date close to current year but in the past\n+        (create_rfc850_date(current_year_2d - 1), current_year - 1),\n+        \n+        # Date in near future (less than 50 years)\n+        (create_rfc850_date((current_year + 1) % 100), current_year + 1),\n+        \n+        # Date exactly 50 years in future should use past century\n+        (create_rfc850_date((current_year + 50) % 100), current_year - 50),\n+        \n+        # Date more than 50 years in future should use past century\n+        (create_rfc850_date((current_year + 51) % 100), current_year - 49),\n+    ]\n+\n+    passed = True\n+    for test_date, expected_year in test_cases:\n+        try:\n+            parsed = datetime.datetime.utcfromtimestamp(parse_http_date(test_date))\n+            actual_year = parsed.year\n+            if actual_year != expected_year:\n+                print(f\"FAILED: {test_date}\")\n+                print(f\"Expected year: {expected_year}, got: {actual_year}\")\n+                passed = False\n+            else:\n+                print(f\"PASSED: {test_date} -> {actual_year}\")\n+        except Exception as e:\n+            print(f\"ERROR: {test_date} raised {str(e)}\")\n+            passed = False\n+\n+    if passed:\n+        print(\"\\nAll tests PASSED!\")\n+    else:\n+        print(\"\\nSome tests FAILED!\")\n+\n+if __name__ == \"__main__\":\n+    test_parse_http_date()\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}