diff --git a/django/utils/http.py b/django/utils/http.py
index 572cfb4347..d54916aae0 100644
--- a/django/utils/http.py
+++ b/django/utils/http.py
@@ -155,6 +155,32 @@ def http_date(epoch_seconds=None):
     return formatdate(epoch_seconds, usegmt=True)
 
 
+def _convert_two_digit_year(year):
+    """
+    Convert a two-digit year to a four-digit year following RFC 7231 rules.
+    
+    Recipients of a timestamp value in rfc850-date format, which uses a two-digit
+    year, MUST interpret a timestamp that appears to be more than 50 years in
+    the future as representing the most recent year in the past that had the
+    same last two digits.
+    """
+    if year >= 100:
+        return year
+
+    current_year = datetime.datetime.now().year
+    two_digit_year = year % 100
+    current_century = current_year // 100
+    
+    # Calculate year in current century
+    candidate_year = (current_century * 100) + two_digit_year
+    
+    # If the candidate year would be more than 50 years in the future,
+    # use the previous century instead
+    if candidate_year > current_year + 50:
+        return ((current_century - 1) * 100) + two_digit_year
+            
+    return candidate_year
+
 def parse_http_date(date):
     """
     Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.
@@ -175,11 +201,7 @@ def parse_http_date(date):
         raise ValueError("%r is not in a valid HTTP date format" % date)
     try:
         year = int(m.group('year'))
-        if year < 100:
-            if year < 70:
-                year += 2000
-            else:
-                year += 1900
+        year = _convert_two_digit_year(year)
         month = MONTHS.index(m.group('mon').lower()) + 1
         day = int(m.group('day'))
         hour = int(m.group('hour'))
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..60b969fcfb
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,52 @@
+import datetime
+from django.utils.http import parse_http_date
+
+def test_parse_http_date():
+    # Helper function to create test dates
+    def create_rfc850_date(year, month=11, day=6):
+        return f"Sunday, {day:02d}-Nov-{year:02d} 08:49:37 GMT"
+
+    # Get current year for testing
+    current_year = datetime.datetime.now().year
+    current_year_2d = current_year % 100
+    
+    # Test cases
+    test_cases = [
+        # Basic test - date in the past
+        (create_rfc850_date(94), 1994),
+        
+        # Date close to current year but in the past
+        (create_rfc850_date(current_year_2d - 1), current_year - 1),
+        
+        # Date in near future (less than 50 years)
+        (create_rfc850_date((current_year + 1) % 100), current_year + 1),
+        
+        # Date exactly 50 years in future should use past century
+        (create_rfc850_date((current_year + 50) % 100), current_year - 50),
+        
+        # Date more than 50 years in future should use past century
+        (create_rfc850_date((current_year + 51) % 100), current_year - 49),
+    ]
+
+    passed = True
+    for test_date, expected_year in test_cases:
+        try:
+            parsed = datetime.datetime.utcfromtimestamp(parse_http_date(test_date))
+            actual_year = parsed.year
+            if actual_year != expected_year:
+                print(f"FAILED: {test_date}")
+                print(f"Expected year: {expected_year}, got: {actual_year}")
+                passed = False
+            else:
+                print(f"PASSED: {test_date} -> {actual_year}")
+        except Exception as e:
+            print(f"ERROR: {test_date} raised {str(e)}")
+            passed = False
+
+    if passed:
+        print("\nAll tests PASSED!")
+    else:
+        print("\nSome tests FAILED!")
+
+if __name__ == "__main__":
+    test_parse_http_date()
\ No newline at end of file
