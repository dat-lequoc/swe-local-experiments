{
  "instance_id": "django__django-13551",
  "model_patch": "diff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 3a4a64ee19..9d589e653b 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -45,6 +45,18 @@ class BaseUserManager(models.Manager):\n         return self.get(**{self.model.USERNAME_FIELD: username})\n \n \n+    def get_email_auth_hash(self):\n+        \"\"\"\n+        Return a hash of the user's primary key and email.\n+        Used for password reset token generation.\n+        \"\"\"\n+        from django.utils.crypto import salted_hmac\n+        return salted_hmac(\n+            'AbstractBaseUser.get_email_auth_hash',\n+            str(self.pk) + str(getattr(self, 'email', '')),\n+            algorithm='sha256'\n+        ).hexdigest()\n+\n class AbstractBaseUser(models.Model):\n     password = models.CharField(_('password'), max_length=128)\n     last_login = models.DateTimeField(_('last login'), blank=True, null=True)\ndiff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..f0c228cd30 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -94,7 +94,9 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Include email hash in token generation\n+        email_hash = getattr(user, 'get_email_auth_hash', lambda: '')()\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + str(email_hash)\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..732002b05f\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,62 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test.utils import get_runner\n+from django.test import TestCase\n+from django.contrib.auth.models import User\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+            'django.contrib.sessions',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        ],\n+        PASSWORD_HASHERS=['django.contrib.auth.hashers.SHA1PasswordHasher'],\n+        SECRET_KEY='dummy-key',\n+        ROOT_URLCONF='django.contrib.auth.urls',\n+        DEBUG=True,\n+    )\n+\n+django.setup()\n+\n+class EmailChangeTokenTest(TestCase):\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"\n+        Test that password reset tokens are invalidated when email is changed.\n+        \"\"\"\n+        # Create a user\n+        user = User.objects.create_user('testuser', 'initial@example.com', 'testpass')\n+        \n+        # Generate a password reset token\n+        token_generator = PasswordResetTokenGenerator()\n+        token = token_generator.make_token(user)\n+        \n+        # Verify the token is valid\n+        self.assertTrue(token_generator.check_token(user, token))\n+        \n+        # Change the user's email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertFalse(token_generator.check_token(user, token))\n+\n+if __name__ == '__main__':\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner()\n+    failures = test_runner.run_tests(['__main__'])\n+    sys.exit(bool(failures))\n\\ No newline at end of file\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..c7d665314b\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,22 @@\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+\n+INSTALLED_APPS = [\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'django.contrib.sessions',\n+]\n+\n+MIDDLEWARE = [\n+    'django.contrib.sessions.middleware.SessionMiddleware',\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\n+]\n+\n+PASSWORD_HASHERS = ['django.contrib.auth.hashers.SHA1PasswordHasher']\n+SECRET_KEY = 'dummy-key'\n+ROOT_URLCONF = 'django.contrib.auth.urls'\n+DEBUG = True\n\\ No newline at end of file\ndiff --git a/test_token.py b/test_token.py\nnew file mode 100644\nindex 0000000000..f26878aca4\n--- /dev/null\n+++ b/test_token.py\n@@ -0,0 +1,47 @@\n+from django.conf import settings\n+\n+if not settings.configured:\n+    settings.configure(\n+        SECRET_KEY='dummy-key',\n+        DEFAULT_HASHING_ALGORITHM='sha256',\n+        PASSWORD_RESET_TIMEOUT=60*60*24*3,  # 3 days\n+    )\n+\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.utils.crypto import salted_hmac\n+\n+class MockUser:\n+    def __init__(self, pk, email, password):\n+        self.pk = pk\n+        self.email = email\n+        self.password = password\n+        self.last_login = None\n+    \n+    def get_email_auth_hash(self):\n+        return salted_hmac(\n+            'AbstractBaseUser.get_email_auth_hash',\n+            str(self.pk) + str(self.email),\n+            algorithm='sha256'\n+        ).hexdigest()\n+\n+def test_token_invalidation():\n+    # Create a mock user\n+    user = MockUser(1, 'initial@example.com', 'password123')\n+    \n+    # Generate token\n+    token_generator = PasswordResetTokenGenerator()\n+    token = token_generator.make_token(user)\n+    \n+    # Verify token is valid\n+    assert token_generator.check_token(user, token), \"Token should be valid initially\"\n+    \n+    # Change email\n+    user.email = 'changed@example.com'\n+    \n+    # Token should be invalid\n+    assert not token_generator.check_token(user, token), \"Token should be invalid after email change\"\n+    \n+    print(\"All tests passed!\")\n+\n+if __name__ == '__main__':\n+    test_token_invalidation()\n\\ No newline at end of file\ndiff --git a/tests/auth_tests/test_email_change_token.py b/tests/auth_tests/test_email_change_token.py\nnew file mode 100644\nindex 0000000000..ba61473558\n--- /dev/null\n+++ b/tests/auth_tests/test_email_change_token.py\n@@ -0,0 +1,49 @@\n+from datetime import datetime\n+\n+from django.conf import settings\n+from django.contrib.auth.models import User\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from django.test import TestCase, override_settings\n+\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+        ],\n+        PASSWORD_HASHERS=['django.contrib.auth.hashers.SHA1PasswordHasher'],\n+        SECRET_KEY='dummy-key',\n+        ROOT_URLCONF='django.contrib.auth.urls',\n+    )\n+\n+import django\n+django.setup()\n+\n+\n+class EmailChangeTokenTest(TestCase):\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"\n+        Test that password reset tokens are invalidated when email is changed.\n+        \"\"\"\n+        # Create a user\n+        user = User.objects.create_user('testuser', 'initial@example.com', 'testpass')\n+        \n+        # Generate a password reset token\n+        token_generator = PasswordResetTokenGenerator()\n+        token = token_generator.make_token(user)\n+        \n+        # Verify the token is valid\n+        self.assertTrue(token_generator.check_token(user, token))\n+        \n+        # Change the user's email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertFalse(token_generator.check_token(user, token))\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}