diff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py
index 3a4a64ee19..9d589e653b 100644
--- a/django/contrib/auth/base_user.py
+++ b/django/contrib/auth/base_user.py
@@ -45,6 +45,18 @@ class BaseUserManager(models.Manager):
         return self.get(**{self.model.USERNAME_FIELD: username})
 
 
+    def get_email_auth_hash(self):
+        """
+        Return a hash of the user's primary key and email.
+        Used for password reset token generation.
+        """
+        from django.utils.crypto import salted_hmac
+        return salted_hmac(
+            'AbstractBaseUser.get_email_auth_hash',
+            str(self.pk) + str(getattr(self, 'email', '')),
+            algorithm='sha256'
+        ).hexdigest()
+
 class AbstractBaseUser(models.Model):
     password = models.CharField(_('password'), max_length=128)
     last_login = models.DateTimeField(_('last login'), blank=True, null=True)
diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py
index 93e2d71af2..f0c228cd30 100644
--- a/django/contrib/auth/tokens.py
+++ b/django/contrib/auth/tokens.py
@@ -94,7 +94,9 @@ class PasswordResetTokenGenerator:
         # Truncate microseconds so that tokens are consistent even if the
         # database doesn't support microseconds.
         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)
-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)
+        # Include email hash in token generation
+        email_hash = getattr(user, 'get_email_auth_hash', lambda: '')()
+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + str(email_hash)
 
     def _num_seconds(self, dt):
         return int((dt - datetime(2001, 1, 1)).total_seconds())
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..732002b05f
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+from django.test.utils import get_runner
+from django.test import TestCase
+from django.contrib.auth.models import User
+from django.contrib.auth.tokens import PasswordResetTokenGenerator
+
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+        ],
+        MIDDLEWARE=[
+            'django.contrib.sessions.middleware.SessionMiddleware',
+            'django.contrib.auth.middleware.AuthenticationMiddleware',
+        ],
+        PASSWORD_HASHERS=['django.contrib.auth.hashers.SHA1PasswordHasher'],
+        SECRET_KEY='dummy-key',
+        ROOT_URLCONF='django.contrib.auth.urls',
+        DEBUG=True,
+    )
+
+django.setup()
+
+class EmailChangeTokenTest(TestCase):
+    def test_token_invalidated_on_email_change(self):
+        """
+        Test that password reset tokens are invalidated when email is changed.
+        """
+        # Create a user
+        user = User.objects.create_user('testuser', 'initial@example.com', 'testpass')
+        
+        # Generate a password reset token
+        token_generator = PasswordResetTokenGenerator()
+        token = token_generator.make_token(user)
+        
+        # Verify the token is valid
+        self.assertTrue(token_generator.check_token(user, token))
+        
+        # Change the user's email
+        user.email = 'changed@example.com'
+        user.save()
+        
+        # Token should now be invalid
+        self.assertFalse(token_generator.check_token(user, token))
+
+if __name__ == '__main__':
+    TestRunner = get_runner(settings)
+    test_runner = TestRunner()
+    failures = test_runner.run_tests(['__main__'])
+    sys.exit(bool(failures))
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..c7d665314b
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,22 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+
+INSTALLED_APPS = [
+    'django.contrib.auth',
+    'django.contrib.contenttypes',
+    'django.contrib.sessions',
+]
+
+MIDDLEWARE = [
+    'django.contrib.sessions.middleware.SessionMiddleware',
+    'django.contrib.auth.middleware.AuthenticationMiddleware',
+]
+
+PASSWORD_HASHERS = ['django.contrib.auth.hashers.SHA1PasswordHasher']
+SECRET_KEY = 'dummy-key'
+ROOT_URLCONF = 'django.contrib.auth.urls'
+DEBUG = True
\ No newline at end of file
diff --git a/test_token.py b/test_token.py
new file mode 100644
index 0000000000..f26878aca4
--- /dev/null
+++ b/test_token.py
@@ -0,0 +1,47 @@
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        SECRET_KEY='dummy-key',
+        DEFAULT_HASHING_ALGORITHM='sha256',
+        PASSWORD_RESET_TIMEOUT=60*60*24*3,  # 3 days
+    )
+
+from django.contrib.auth.tokens import PasswordResetTokenGenerator
+from django.utils.crypto import salted_hmac
+
+class MockUser:
+    def __init__(self, pk, email, password):
+        self.pk = pk
+        self.email = email
+        self.password = password
+        self.last_login = None
+    
+    def get_email_auth_hash(self):
+        return salted_hmac(
+            'AbstractBaseUser.get_email_auth_hash',
+            str(self.pk) + str(self.email),
+            algorithm='sha256'
+        ).hexdigest()
+
+def test_token_invalidation():
+    # Create a mock user
+    user = MockUser(1, 'initial@example.com', 'password123')
+    
+    # Generate token
+    token_generator = PasswordResetTokenGenerator()
+    token = token_generator.make_token(user)
+    
+    # Verify token is valid
+    assert token_generator.check_token(user, token), "Token should be valid initially"
+    
+    # Change email
+    user.email = 'changed@example.com'
+    
+    # Token should be invalid
+    assert not token_generator.check_token(user, token), "Token should be invalid after email change"
+    
+    print("All tests passed!")
+
+if __name__ == '__main__':
+    test_token_invalidation()
\ No newline at end of file
diff --git a/tests/auth_tests/test_email_change_token.py b/tests/auth_tests/test_email_change_token.py
new file mode 100644
index 0000000000..ba61473558
--- /dev/null
+++ b/tests/auth_tests/test_email_change_token.py
@@ -0,0 +1,49 @@
+from datetime import datetime
+
+from django.conf import settings
+from django.contrib.auth.models import User
+from django.contrib.auth.tokens import PasswordResetTokenGenerator
+from django.test import TestCase, override_settings
+
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        PASSWORD_HASHERS=['django.contrib.auth.hashers.SHA1PasswordHasher'],
+        SECRET_KEY='dummy-key',
+        ROOT_URLCONF='django.contrib.auth.urls',
+    )
+
+import django
+django.setup()
+
+
+class EmailChangeTokenTest(TestCase):
+    def test_token_invalidated_on_email_change(self):
+        """
+        Test that password reset tokens are invalidated when email is changed.
+        """
+        # Create a user
+        user = User.objects.create_user('testuser', 'initial@example.com', 'testpass')
+        
+        # Generate a password reset token
+        token_generator = PasswordResetTokenGenerator()
+        token = token_generator.make_token(user)
+        
+        # Verify the token is valid
+        self.assertTrue(token_generator.check_token(user, token))
+        
+        # Change the user's email
+        user.email = 'changed@example.com'
+        user.save()
+        
+        # Token should now be invalid
+        self.assertFalse(token_generator.check_token(user, token))
\ No newline at end of file
