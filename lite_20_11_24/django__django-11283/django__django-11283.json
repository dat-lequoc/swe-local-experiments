{
  "instance_id": "django__django-11283",
  "model_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..f199825df0 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -5,29 +5,68 @@ from django.db.models import Q\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n-    of the proxy model.\n+    of the proxy model. Handles duplicate permissions by merging them and preserving\n+    user/group assignments.\n     \"\"\"\n     Permission = apps.get_model('auth', 'Permission')\n     ContentType = apps.get_model('contenttypes', 'ContentType')\n+    Group = apps.get_model('auth', 'Group')\n+    User = apps.get_model('auth', 'User')\n+\n+    # Process each proxy model\n     for Model in apps.get_models():\n         opts = Model._meta\n         if not opts.proxy:\n             continue\n-        proxy_default_permissions_codenames = [\n-            '%s_%s' % (action, opts.model_name)\n-            for action in opts.default_permissions\n-        ]\n-        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n-        for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n-            permissions_query,\n-            content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+\n+        # Get all permissions for this model\n+        all_perms = Permission.objects.filter(\n+            Q(content_type=old_content_type) | Q(content_type=new_content_type)\n+        ).select_related('content_type')\n+\n+        # Process permissions by codename\n+        processed_codenames = set()\n+        for perm in all_perms:\n+            if perm.codename in processed_codenames:\n+                continue\n+            processed_codenames.add(perm.codename)\n+\n+            # Find all permissions with this codename\n+            duplicate_perms = all_perms.filter(codename=perm.codename).order_by('id')\n+            if duplicate_perms.count() <= 1:\n+                # If only one permission exists, just update its content_type if needed\n+                if perm.content_type != new_content_type:\n+                    perm.content_type = new_content_type\n+                    perm.save(update_fields=['content_type'])\n+                continue\n+\n+            # Get or create the target permission\n+            target_perm = duplicate_perms.filter(content_type=new_content_type).first()\n+            if not target_perm:\n+                # If no permission exists with new content type, update the first one\n+                target_perm = duplicate_perms.first()\n+                target_perm.content_type = new_content_type\n+                target_perm.save(update_fields=['content_type'])\n+\n+            # Transfer all relationships to the target permission\n+            for other_perm in duplicate_perms.exclude(pk=target_perm.pk):\n+                # Transfer group permissions\n+                Group.objects.filter(permissions=other_perm).update(\n+                    permissions=target_perm\n+                )\n+\n+                # Transfer user permissions\n+                User.objects.filter(user_permissions=other_perm).update(\n+                    user_permissions=target_perm\n+                )\n+\n+                # Delete the other permission\n+                other_perm.delete()\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\ndiff --git a/run_tests.py b/run_tests.py\nnew file mode 100644\nindex 0000000000..2f8f2e35c1\n--- /dev/null\n+++ b/run_tests.py\n@@ -0,0 +1,12 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.test.utils import get_runner\n+\n+if __name__ == \"__main__\":\n+    os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_settings'\n+    django.setup()\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner()\n+    failures = test_runner.run_tests([\"tests.auth_tests.test_migrations\"])\n+    exit(bool(failures))\n\\ No newline at end of file\ndiff --git a/test_migration.py b/test_migration.py\nnew file mode 100644\nindex 0000000000..649f4c022a\n--- /dev/null\n+++ b/test_migration.py\n@@ -0,0 +1,30 @@\n+import os\n+import django\n+from django.db import connection\n+from django.test.utils import setup_test_environment\n+from django.core.management import call_command\n+\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_settings'\n+django.setup()\n+\n+# Set up test environment\n+setup_test_environment()\n+\n+# Create test database\n+connection.creation.create_test_db(verbosity=1)\n+\n+try:\n+    # Run migrations\n+    call_command('migrate', verbosity=1)\n+    \n+    # Import and run the migration directly\n+    from django.contrib.auth.migrations import update_proxy_model_permissions\n+    from django.apps import apps\n+    \n+    # Run the migration function\n+    update_proxy_model_permissions(apps, None)\n+    print(\"Migration completed successfully\")\n+    \n+finally:\n+    # Clean up test database\n+    connection.creation.destroy_test_db(verbosity=1)\n\\ No newline at end of file\ndiff --git a/test_proxy_permissions.py b/test_proxy_permissions.py\nnew file mode 100644\nindex 0000000000..636c93dc4c\n--- /dev/null\n+++ b/test_proxy_permissions.py\n@@ -0,0 +1,119 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.core.management import call_command\n+from django.apps import apps as global_apps\n+\n+# Configure Django settings before importing models\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+        ],\n+        SECRET_KEY='dummy-key-for-tests',\n+    )\n+    django.setup()\n+\n+# Import Django components after setup\n+from django.db import connection\n+from django.contrib.auth.models import Permission, User, Group\n+from django.contrib.contenttypes.models import ContentType\n+from django.test import TransactionTestCase\n+from django.db.migrations.executor import MigrationExecutor\n+\n+# Create a proxy model for testing\n+class UserProxy(User):\n+    class Meta:\n+        proxy = True\n+        app_label = 'auth'  # Use the same app_label as User to avoid migration issues\n+\n+class TestProxyPermissions(TransactionTestCase):\n+    def setUp(self):\n+        super().setUp()\n+        # Create concrete content type\n+        self.concrete_content_type = ContentType.objects.get_for_model(User)\n+        self.proxy_content_type = ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        \n+        # Create test permission on concrete model\n+        self.perm = Permission.objects.create(\n+            content_type=self.concrete_content_type,\n+            codename='test_perm',\n+            name='Test Permission'\n+        )\n+        \n+        # Create a duplicate permission (simulating the issue)\n+        self.dup_perm = Permission.objects.create(\n+            content_type=self.proxy_content_type,\n+            codename='test_perm',\n+            name='Test Permission'\n+        )\n+\n+        # Create test user and group\n+        self.user = User.objects.create_user('testuser', 'test@example.com', 'password')\n+        self.group = Group.objects.create(name='testgroup')\n+        \n+        # Assign permissions to user and group\n+        self.user.user_permissions.add(self.perm)\n+        self.group.permissions.add(self.dup_perm)\n+\n+    def test_update_proxy_permissions(self):\n+        import importlib\n+        update_proxy_permissions = importlib.import_module('django.contrib.auth.migrations.0011_update_proxy_permissions')\n+        \n+        # Get the migration executor\n+        executor = MigrationExecutor(connection)\n+        \n+        # Run the migration function with the apps from the migration executor\n+        update_proxy_permissions.update_proxy_model_permissions(executor.loader.project_state().apps, None)\n+        \n+        # Verify the results\n+        # The permissions should be merged, with users/groups preserved\n+        permissions = Permission.objects.filter(codename='test_perm')\n+        self.assertEqual(permissions.count(), 1, \"Should have exactly one permission after merge\")\n+        \n+        remaining_perm = permissions.first()\n+        self.assertEqual(remaining_perm.content_type, self.proxy_content_type, \n+                        \"Remaining permission should use proxy model content type\")\n+        \n+        # Verify user permissions were preserved\n+        self.user.refresh_from_db()\n+        self.assertTrue(self.user.has_perm('auth.test_perm'), \n+                       \"User should still have permission after merge\")\n+        \n+        # Verify group permissions were preserved\n+        self.group.refresh_from_db()\n+        self.assertTrue(self.group.permissions.filter(codename='test_perm').exists(),\n+                       \"Group should still have permission after merge\")\n+\n+    def test_update_proxy_permissions_reverse(self):\n+        \"\"\"Test the reverse migration\"\"\"\n+        import importlib\n+        update_proxy_permissions = importlib.import_module('django.contrib.auth.migrations.0011_update_proxy_permissions')\n+        \n+        # Get the migration executor\n+        executor = MigrationExecutor(connection)\n+        \n+        # Run the reverse migration\n+        update_proxy_permissions.revert_proxy_model_permissions(executor.loader.project_state().apps, None)\n+        \n+        # Verify the results\n+        permissions = Permission.objects.filter(codename='test_perm')\n+        self.assertEqual(permissions.count(), 1, \"Should have exactly one permission after reverse\")\n+        \n+        remaining_perm = permissions.first()\n+        self.assertEqual(remaining_perm.content_type, self.concrete_content_type,\n+                        \"Remaining permission should use concrete model content type\")\n+\n+if __name__ == '__main__':\n+    # Run the test\n+    from django.test.runner import DiscoverRunner\n+    test_runner = DiscoverRunner(verbosity=2)\n+    failures = test_runner.run_tests(['__main__'])\n+    exit(bool(failures))\n\\ No newline at end of file\ndiff --git a/tests/auth_tests/migrations/0001_initial.py b/tests/auth_tests/migrations/0001_initial.py\nnew file mode 100644\nindex 0000000000..2b87c19767\n--- /dev/null\n+++ b/tests/auth_tests/migrations/0001_initial.py\n@@ -0,0 +1,32 @@\n+from django.db import migrations, models\n+from django.contrib.auth import get_user_model\n+\n+class Migration(migrations.Migration):\n+    initial = True\n+\n+    dependencies = [\n+        ('auth', '0011_update_proxy_permissions'),\n+    ]\n+\n+    operations = [\n+        migrations.CreateModel(\n+            name='UserProxy',\n+            fields=[],\n+            options={\n+                'proxy': True,\n+                'indexes': [],\n+                'constraints': [],\n+            },\n+            bases=('auth.user',),\n+        ),\n+        migrations.CreateModel(\n+            name='Proxy',\n+            fields=[],\n+            options={\n+                'proxy': True,\n+                'indexes': [],\n+                'constraints': [],\n+            },\n+            bases=('auth.user',),\n+        ),\n+    ]\n\\ No newline at end of file\ndiff --git a/tests/auth_tests/migrations/__init__.py b/tests/auth_tests/migrations/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/tests/auth_tests/models.py b/tests/auth_tests/models.py\nnew file mode 100644\nindex 0000000000..60bc090659\n--- /dev/null\n+++ b/tests/auth_tests/models.py\n@@ -0,0 +1,9 @@\n+from django.contrib.auth.models import User\n+\n+class UserProxy(User):\n+    class Meta:\n+        proxy = True\n+\n+class Proxy(User):\n+    class Meta:\n+        proxy = True\n\\ No newline at end of file\ndiff --git a/tests/test_settings.py b/tests/test_settings.py\nnew file mode 100644\nindex 0000000000..a2e36b1763\n--- /dev/null\n+++ b/tests/test_settings.py\n@@ -0,0 +1,27 @@\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+\n+INSTALLED_APPS = [\n+    'django.contrib.admin',\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'django.contrib.sessions',\n+    'django.contrib.messages',\n+    'django.contrib.staticfiles',\n+]\n+\n+MIDDLEWARE = [\n+    'django.middleware.security.SecurityMiddleware',\n+    'django.contrib.sessions.middleware.SessionMiddleware',\n+    'django.middleware.common.CommonMiddleware',\n+    'django.middleware.csrf.CsrfViewMiddleware',\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\n+    'django.contrib.messages.middleware.MessageMiddleware',\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n+]\n+\n+SECRET_KEY = 'dummy-key-for-tests'\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}