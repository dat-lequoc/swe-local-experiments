diff --git a/django/contrib/staticfiles/handlers.py b/django/contrib/staticfiles/handlers.py
index 711d8864ad..51d0b75884 100644
--- a/django/contrib/staticfiles/handlers.py
+++ b/django/contrib/staticfiles/handlers.py
@@ -1,13 +1,19 @@
+import logging
+import os
 from urllib.parse import urlparse
 from urllib.request import url2pathname
 
+from asgiref.sync import sync_to_async
 from django.conf import settings
-from django.contrib.staticfiles import utils
+from django.contrib.staticfiles import utils, finders
 from django.contrib.staticfiles.views import serve
 from django.core.handlers.asgi import ASGIHandler
 from django.core.handlers.exception import response_for_exception
 from django.core.handlers.wsgi import WSGIHandler, get_path_info
 from django.http import Http404
+from django.views.static import serve as static_serve
+
+logger = logging.getLogger('django.request')
 
 
 class StaticFilesHandlerMixin:
@@ -39,12 +45,45 @@ class StaticFilesHandlerMixin:
         """
         Return the relative path to the media file on disk for the given URL.
         """
+        from django.contrib.staticfiles import finders
+        import os
+        
+        # Get the relative URL by removing the STATIC_URL prefix
         relative_url = url[len(self.base_url[2]):]
-        return url2pathname(relative_url)
+        # Convert URL path to filesystem path
+        file_path = url2pathname(relative_url.lstrip('/'))
+        # Normalize the path
+        file_path = os.path.normpath(file_path)
+        
+        # Try to find the file using the static file finder
+        absolute_path = finders.find(file_path)
+        if absolute_path:
+            # If found, return the path relative to the finder's root
+            return os.path.relpath(absolute_path, settings.STATIC_ROOT)
+            
+        return file_path
 
     def serve(self, request):
         """Serve the request path."""
-        return serve(request, self.file_path(request.path), insecure=True)
+        # Get the relative path from the URL
+        relative_path = request.path[len(self.base_url[2]):]
+        if not relative_path:
+            raise Http404('Empty static file path')
+            
+        # Clean the path
+        relative_path = os.path.normpath(relative_path).lstrip('/')
+        
+        # Try to find the file using the static file finder
+        absolute_path = finders.find(relative_path)
+        if absolute_path:
+            return static_serve(request, os.path.basename(absolute_path), document_root=os.path.dirname(absolute_path))
+            
+        # If finder fails, try serving from STATIC_ROOT
+        full_path = os.path.join(settings.STATIC_ROOT, relative_path)
+        if os.path.exists(full_path) and os.path.isfile(full_path):
+            return static_serve(request, relative_path, document_root=settings.STATIC_ROOT)
+            
+        raise Http404('Static file not found')
 
     def get_response(self, request):
         try:
@@ -52,6 +91,15 @@ class StaticFilesHandlerMixin:
         except Http404 as e:
             return response_for_exception(request, e)
 
+    async def get_response_async(self, request):
+        """Async version of get_response."""
+        if self._should_handle(request.path):
+            try:
+                return await sync_to_async(self.serve, thread_sensitive=True)(request)
+            except Http404 as e:
+                return await sync_to_async(response_for_exception, thread_sensitive=True)(request, e)
+        return await super().get_response_async(request)
+
 
 class StaticFilesHandler(StaticFilesHandlerMixin, WSGIHandler):
     """
@@ -79,10 +127,26 @@ class ASGIStaticFilesHandler(StaticFilesHandlerMixin, ASGIHandler):
         self.base_url = urlparse(self.get_base_url())
 
     async def __call__(self, scope, receive, send):
-        # Only even look at HTTP requests
-        if scope['type'] == 'http' and self._should_handle(scope['path']):
-            # Serve static content
-            # (the one thing super() doesn't do is __call__, apparently)
-            return await super().__call__(scope, receive, send)
-        # Hand off to the main app
-        return await self.application(scope, receive, send)
+        """
+        ASGI entry point. Determine if the request should use static file handling.
+        """
+        if scope['type'] == 'http':
+            if self._should_handle(scope['path']):
+                # Serve static content
+                return await super().__call__(scope, receive, send)
+            elif self.application:
+                # Hand off to the main app
+                return await self.application(scope, receive, send)
+        return await super().__call__(scope, receive, send)
+
+    async def get_response_async(self, request):
+        """
+        Async version of get_response that handles static files.
+        """
+        if self._should_handle(request.path):
+            try:
+                response = await sync_to_async(self.serve, thread_sensitive=True)(request)
+                return response
+            except Http404:
+                pass
+        return await super().get_response_async(request)
diff --git a/tests/staticfiles_tests/test_handlers.py b/tests/staticfiles_tests/test_handlers.py
new file mode 100644
index 0000000000..e4830e57ca
--- /dev/null
+++ b/tests/staticfiles_tests/test_handlers.py
@@ -0,0 +1,71 @@
+import asyncio
+import os
+import django
+from django.test import SimpleTestCase, override_settings
+from django.conf import settings
+
+# Configure Django settings before importing other modules
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+        STATIC_ROOT=os.path.join(os.path.dirname(__file__), 'static'),
+        STATICFILES_DIRS=[],
+        INSTALLED_APPS=['django.contrib.staticfiles'],
+        ROOT_URLCONF='django.contrib.staticfiles.urls',
+        ALLOWED_HOSTS=['*'],
+        MIDDLEWARE=[],
+        STATICFILES_FINDERS=[
+            'django.contrib.staticfiles.finders.FileSystemFinder',
+        ],
+    )
+    django.setup()
+
+from django.contrib.staticfiles.handlers import ASGIStaticFilesHandler
+from django.core.handlers.asgi import ASGIRequest
+from django.http import Http404
+
+class ASGIStaticFilesHandlerTest(SimpleTestCase):
+    async def test_get_response_async(self):
+        """
+        Test that ASGIStaticFilesHandler.get_response_async works correctly
+        """
+        handler = ASGIStaticFilesHandler(None)
+        scope = {
+            'type': 'http',
+            'method': 'GET',
+            'path': '/static/test.txt',
+            'headers': [],
+        }
+        request = ASGIRequest(scope, None)
+        
+        # Test non-existing file
+        response = await handler.get_response_async(request)
+        self.assertEqual(response.status_code, 404)
+
+        # Create a test static file
+        os.makedirs(os.path.join(settings.STATIC_ROOT, 'test'), exist_ok=True)
+        test_file = os.path.join(settings.STATIC_ROOT, 'test', 'test.txt')
+        with open(test_file, 'w') as f:
+            f.write('test content')
+
+        try:
+            # Test existing file
+            scope['path'] = '/static/test/test.txt'
+            request = ASGIRequest(scope, None)
+            # Debug info
+            print(f"STATIC_ROOT: {settings.STATIC_ROOT}")
+            print(f"Test file path: {test_file}")
+            print(f"File exists: {os.path.exists(test_file)}")
+            print(f"Request path: {request.path}")
+            print(f"Handler base_url: {handler.base_url}")
+            print(f"Computed file path: {handler.file_path(request.path)}")
+            
+            response = await handler.get_response_async(request)
+            self.assertEqual(response.status_code, 200)
+            content = b''.join(response.streaming_content)
+            self.assertEqual(content.decode(), 'test content')
+        finally:
+            # Clean up
+            os.unlink(test_file)
+            os.rmdir(os.path.join(settings.STATIC_ROOT, 'test'))
\ No newline at end of file
diff --git a/tests/test_settings.py b/tests/test_settings.py
new file mode 100644
index 0000000000..460011fa82
--- /dev/null
+++ b/tests/test_settings.py
@@ -0,0 +1,22 @@
+import os
+
+SECRET_KEY = 'test_key'
+INSTALLED_APPS = [
+    'django.contrib.staticfiles',
+]
+STATIC_URL = '/static/'
+STATIC_ROOT = os.path.join(os.path.dirname(__file__), 'static')
+STATICFILES_DIRS = [os.path.join(os.path.dirname(__file__), 'staticfiles_tests', 'static')]
+DEBUG = True
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+USE_TZ = False
+ROOT_URLCONF = 'tests.urls'
+
+MIDDLEWARE = [
+    'django.middleware.common.CommonMiddleware',
+]
\ No newline at end of file
