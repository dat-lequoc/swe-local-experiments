{
  "instance_id": "django__django-11001",
  "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39262..9a8099b48b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,7 +353,12 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize the SQL by removing newlines and extra whitespace\n+            sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+            match = self.ordering_parts.search(sql_oneline)\n+            if not match:\n+                continue\n+            without_ordering = match.group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\ndiff --git a/edge_cases.py b/edge_cases.py\nnew file mode 100644\nindex 0000000000..5e816ac3d6\n--- /dev/null\n+++ b/edge_cases.py\n@@ -0,0 +1,71 @@\n+from django.db.models.sql.compiler import SQLCompiler\n+\n+def test_edge_cases():\n+    compiler = SQLCompiler(None, None, None)\n+    \n+    # Test case 1: Empty SQL\n+    sql = \"\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is None\n+    \n+    # Test case 2: SQL with only whitespace\n+    sql = \"   \\n   \\r   \\t   \"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is None\n+    \n+    # Test case 3: SQL with mixed line endings\n+    sql = \"case\\rwhen\\nstatus\\r\\nin\\n\\r('active')\\rthen\\n1\\relse\\r\\n0\\rend\\nASC\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is not None\n+    without_ordering = match.group(1)\n+    assert without_ordering == \"case when status in ('active') then 1 else 0 end\"\n+    \n+    # Test case 4: SQL with unicode characters\n+    sql = \"\"\"\n+        case when status = '\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0439' \n+             then '\u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442'\n+             else '\u043e\u0431\u044b\u0447\u043d\u044b\u0439' end DESC\n+    \"\"\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is not None\n+    without_ordering = match.group(1)\n+    assert \"\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0439\" in without_ordering\n+    assert \"\u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\" in without_ordering\n+    assert \"\u043e\u0431\u044b\u0447\u043d\u044b\u0439\" in without_ordering\n+    \n+    # Test case 5: SQL with multiple ASC/DESC occurrences\n+    sql = \"\"\"\n+        case when status = 'DESC'\n+             then 'ASC' \n+             else 'DESC' end ASC\n+    \"\"\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is not None\n+    without_ordering = match.group(1)\n+    assert \"status = 'DESC'\" in without_ordering\n+    assert \"'ASC'\" in without_ordering\n+    assert \"'DESC'\" in without_ordering\n+    \n+    # Test case 6: SQL with comments\n+    sql = \"\"\"\n+        -- This is a comment with ASC\n+        case when status = 'active' -- Another comment DESC\n+             then 1 /* Comment with ASC */\n+             else 0 end DESC -- Final comment\n+    \"\"\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is not None\n+    without_ordering = match.group(1)\n+    assert \"status = 'active'\" in without_ordering\n+    assert \"then 1\" in without_ordering\n+    assert \"else 0 end\" in without_ordering\n+\n+if __name__ == '__main__':\n+    test_edge_cases()\n+    print(\"All edge cases passed!\")\n\\ No newline at end of file\ndiff --git a/reproduce_error.py b/reproduce_error.py\nnew file mode 100644\nindex 0000000000..06ae338d5c\n--- /dev/null\n+++ b/reproduce_error.py\n@@ -0,0 +1,56 @@\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db.models.expressions import RawSQL\n+\n+def test_multiline_rawsql_ordering():\n+    # Create a mock compiler instance\n+    compiler = SQLCompiler(None, None, None)\n+    \n+    # Test case 1: Single line SQL\n+    sql = \"case when status = 'active' then 1 else 0 end ASC\"\n+    sql_oneline = ' '.join(sql.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match = compiler.ordering_parts.search(sql_oneline)\n+    assert match is not None\n+    without_ordering = match.group(1)\n+    assert without_ordering == \"case when status = 'active' then 1 else 0 end\"\n+\n+    # Test case 2: Multiline SQL with same ending but different content\n+    sql1 = \"\"\"\n+        case when status in ('accepted', 'verification')\n+             then 2 else 1 end DESC\n+    \"\"\"\n+    sql2 = \"\"\"\n+        case when status in ('pending', 'review')\n+             then 2 else 1 end DESC\n+    \"\"\"\n+    \n+    sql1_oneline = ' '.join(sql1.replace('\\r', ' ').replace('\\n', ' ').split())\n+    sql2_oneline = ' '.join(sql2.replace('\\r', ' ').replace('\\n', ' ').split())\n+    \n+    match1 = compiler.ordering_parts.search(sql1_oneline)\n+    match2 = compiler.ordering_parts.search(sql2_oneline)\n+    \n+    assert match1 is not None\n+    assert match2 is not None\n+    \n+    without_ordering1 = match1.group(1)\n+    without_ordering2 = match2.group(1)\n+    \n+    # Verify that different SQL statements are treated as different even with same ending\n+    assert without_ordering1 != without_ordering2\n+    \n+    # Test case 3: Complex multiline SQL with nested conditions\n+    sql3 = \"\"\"\n+        case when status in ('accepted', 'verification')\n+             then (accepted_datetime, preferred_datetime)\n+             else null end ASC\n+    \"\"\"\n+    sql3_oneline = ' '.join(sql3.replace('\\r', ' ').replace('\\n', ' ').split())\n+    match3 = compiler.ordering_parts.search(sql3_oneline)\n+    assert match3 is not None\n+    without_ordering3 = match3.group(1)\n+    assert \"accepted_datetime\" in without_ordering3\n+    assert \"preferred_datetime\" in without_ordering3\n+\n+if __name__ == '__main__':\n+    test_multiline_rawsql_ordering()\n+    print(\"All tests passed!\")\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}