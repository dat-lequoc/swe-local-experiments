{
  "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1926,6 +1926,12 @@ def _check_constraints(cls, databases):\n                         id='models.W038',\n                     )\n                 )\n+            fields = (\n+                field\n+                for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)\n+                for field in constraint.fields\n+            )\n+            errors.extend(cls._check_local_fields(fields, 'constraints'))\n         return errors\n \n \n",
  "test_patch": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1501,3 +1501,70 @@ class Meta:\n                 ]\n \n         self.assertEqual(Model.check(databases=self.databases), [])\n+\n+    def test_unique_constraint_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                constraints = [models.UniqueConstraint(fields=['missing_field'], name='name')]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field \"\n+                \"'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n+    def test_unique_constraint_pointing_to_m2m_field(self):\n+        class Model(models.Model):\n+            m2m = models.ManyToManyField('self')\n+\n+            class Meta:\n+                constraints = [models.UniqueConstraint(fields=['m2m'], name='name')]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n+                \"ManyToManyFields are not permitted in 'constraints'.\",\n+                obj=Model,\n+                id='models.E013',\n+            ),\n+        ])\n+\n+    def test_unique_constraint_pointing_to_non_local_field(self):\n+        class Parent(models.Model):\n+            field1 = models.IntegerField()\n+\n+        class Child(Parent):\n+            field2 = models.IntegerField()\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['field2', 'field1'], name='name'),\n+                ]\n+\n+        self.assertEqual(Child.check(databases=self.databases), [\n+            Error(\n+                \"'constraints' refers to field 'field1' which is not local to \"\n+                \"model 'Child'.\",\n+                hint='This issue may be caused by multi-table inheritance.',\n+                obj=Child,\n+                id='models.E016',\n+            ),\n+        ])\n+\n+    def test_unique_constraint_pointing_to_fk(self):\n+        class Target(models.Model):\n+            pass\n+\n+        class Model(models.Model):\n+            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name='target_1')\n+            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name='target_2')\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['fk_1_id', 'fk_2'], name='name'),\n+                ]\n+\n+        self.assertEqual(Model.check(databases=self.databases), [])\n"
}