{
  "patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,7 +58,14 @@ def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n+        try:\n+            if self.connection.settings_dict['TEST']['MIGRATE'] is False:\n+                # Disable migrations for all apps.\n+                old_migration_modules = settings.MIGRATION_MODULES\n+                settings.MIGRATION_MODULES = {\n+                    app.label: None\n+                    for app in apps.get_app_configs()\n+                }\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n             # testing (unless you really ask to be flooded).\n@@ -69,6 +76,9 @@ def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        finally:\n+            if self.connection.settings_dict['TEST']['MIGRATE'] is False:\n+                settings.MIGRATION_MODULES = old_migration_modules\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n",
  "test_patch": "diff --git a/tests/backends/base/app_unmigrated/__init__.py b/tests/backends/base/app_unmigrated/__init__.py\nnew file mode 100644\ndiff --git a/tests/backends/base/app_unmigrated/migrations/0001_initial.py b/tests/backends/base/app_unmigrated/migrations/0001_initial.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/backends/base/app_unmigrated/migrations/0001_initial.py\n@@ -0,0 +1,17 @@\n+from django.db import migrations, models\n+\n+\n+class Migration(migrations.Migration):\n+    initial = True\n+\n+    dependencies = []\n+\n+    operations = [\n+        migrations.CreateModel(\n+            name='Foo',\n+            fields=[\n+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+                ('name', models.CharField(max_length=255)),\n+            ],\n+        ),\n+    ]\ndiff --git a/tests/backends/base/app_unmigrated/migrations/__init__.py b/tests/backends/base/app_unmigrated/migrations/__init__.py\nnew file mode 100644\ndiff --git a/tests/backends/base/app_unmigrated/models.py b/tests/backends/base/app_unmigrated/models.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/backends/base/app_unmigrated/models.py\n@@ -0,0 +1,8 @@\n+from django.db import models\n+\n+\n+class Foo(models.Model):\n+    name = models.CharField(max_length=255)\n+\n+    class Meta:\n+        app_label = 'app_unmigrated'\ndiff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -6,6 +6,7 @@\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n from django.test import SimpleTestCase, TransactionTestCase\n+from django.test.utils import override_settings\n \n from ..models import (\n     CircularA, CircularB, Object, ObjectReference, ObjectSelfReference,\n@@ -49,31 +50,57 @@ def test_custom_test_name_with_test_prefix(self):\n         self.assertEqual(signature[3], test_name)\n \n \n+@override_settings(INSTALLED_APPS=['backends.base.app_unmigrated'])\n @mock.patch.object(connection, 'ensure_connection')\n-@mock.patch('django.core.management.commands.migrate.Command.handle', return_value=None)\n+@mock.patch.object(connection, 'prepare_database')\n+@mock.patch('django.db.migrations.recorder.MigrationRecorder.has_table', return_value=False)\n+@mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n+@mock.patch('django.core.management.commands.migrate.Command.sync_apps')\n class TestDbCreationTests(SimpleTestCase):\n-    def test_migrate_test_setting_false(self, mocked_migrate, mocked_ensure_connection):\n+    available_apps = ['backends.base.app_unmigrated']\n+\n+    def test_migrate_test_setting_false(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = False\n         creation = test_connection.creation_class(test_connection)\n+        if connection.vendor == 'oracle':\n+            # Don't close connection on Oracle.\n+            creation.connection.close = mock.Mock()\n         old_database_name = test_connection.settings_dict['NAME']\n         try:\n             with mock.patch.object(creation, '_create_test_db'):\n                 creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)\n-            mocked_migrate.assert_not_called()\n+            # Migrations don't run.\n+            mocked_migrate.assert_called()\n+            args, kwargs = mocked_migrate.call_args\n+            self.assertEqual(args, ([],))\n+            self.assertEqual(kwargs['plan'], [])\n+            # App is synced.\n+            mocked_sync_apps.assert_called()\n+            mocked_args, _ = mocked_sync_apps.call_args\n+            self.assertEqual(mocked_args[1], {'app_unmigrated'})\n         finally:\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n \n-    def test_migrate_test_setting_true(self, mocked_migrate, mocked_ensure_connection):\n+    def test_migrate_test_setting_true(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = True\n         creation = test_connection.creation_class(test_connection)\n+        if connection.vendor == 'oracle':\n+            # Don't close connection on Oracle.\n+            creation.connection.close = mock.Mock()\n         old_database_name = test_connection.settings_dict['NAME']\n         try:\n             with mock.patch.object(creation, '_create_test_db'):\n                 creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)\n-            mocked_migrate.assert_called_once()\n+            # Migrations run.\n+            mocked_migrate.assert_called()\n+            args, kwargs = mocked_migrate.call_args\n+            self.assertEqual(args, ([('app_unmigrated', '0001_initial')],))\n+            self.assertEqual(len(kwargs['plan']), 1)\n+            # App is not synced.\n+            mocked_sync_apps.assert_not_called()\n         finally:\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n"
}