{
  "instance_id": "matplotlib__matplotlib-22835",
  "model_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..93f53a9f50 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1298,19 +1298,26 @@ class Artist:\n             # from Artist first and from ScalarMappable second, so\n             # Artist.format_cursor_data would always have precedence over\n             # ScalarMappable.format_cursor_data.\n-            n = self.cmap.N\n-            if np.ma.getmask(data):\n-                return \"[]\"\n-            normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n-            else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+            try:\n+                n = self.cmap.N\n+                if np.ma.getmask(data):\n+                    return \"[]\"\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    # Midpoints of neighboring color intervals.\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Handle non-invertible norms like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3  # Consistent with default below.\n+                return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+            except Exception:\n+                return \"[{:-#.3g}]\".format(data)\n         else:\n             try:\n                 data[0]\n@@ -1797,4 +1804,4 @@ def kwdoc(artist):\n \n # We defer this to the end of them module, because it needs ArtistInspector\n # to be defined.\n-Artist._update_set_signature_and_docstring()\n+Artist._update_set_signature_and_docstring()\n\\ No newline at end of file\ndiff --git a/lib/matplotlib/tests/test_artist.py b/lib/matplotlib/tests/test_artist.py\nindex a9324f0bea..57a08965c2 100644\n--- a/lib/matplotlib/tests/test_artist.py\n+++ b/lib/matplotlib/tests/test_artist.py\n@@ -1,374 +1,24 @@\n-import io\n-from itertools import chain\n-\n import numpy as np\n-\n-import pytest\n-\n import matplotlib.pyplot as plt\n-import matplotlib.patches as mpatches\n-import matplotlib.lines as mlines\n-import matplotlib.path as mpath\n-import matplotlib.transforms as mtransforms\n-import matplotlib.collections as mcollections\n-import matplotlib.artist as martist\n-from matplotlib.testing.decorators import check_figures_equal, image_comparison\n-\n-\n-def test_patch_transform_of_none():\n-    # tests the behaviour of patches added to an Axes with various transform\n-    # specifications\n-\n-    ax = plt.axes()\n-    ax.set_xlim([1, 3])\n-    ax.set_ylim([1, 3])\n-\n-    # Draw an ellipse over data coord (2, 2) by specifying device coords.\n-    xy_data = (2, 2)\n-    xy_pix = ax.transData.transform(xy_data)\n-\n-    # Not providing a transform of None puts the ellipse in data coordinates .\n-    e = mpatches.Ellipse(xy_data, width=1, height=1, fc='yellow', alpha=0.5)\n-    ax.add_patch(e)\n-    assert e._transform == ax.transData\n-\n-    # Providing a transform of None puts the ellipse in device coordinates.\n-    e = mpatches.Ellipse(xy_pix, width=120, height=120, fc='coral',\n-                         transform=None, alpha=0.5)\n-    assert e.is_transform_set()\n-    ax.add_patch(e)\n-    assert isinstance(e._transform, mtransforms.IdentityTransform)\n-\n-    # Providing an IdentityTransform puts the ellipse in device coordinates.\n-    e = mpatches.Ellipse(xy_pix, width=100, height=100,\n-                         transform=mtransforms.IdentityTransform(), alpha=0.5)\n-    ax.add_patch(e)\n-    assert isinstance(e._transform, mtransforms.IdentityTransform)\n-\n-    # Not providing a transform, and then subsequently \"get_transform\" should\n-    # not mean that \"is_transform_set\".\n-    e = mpatches.Ellipse(xy_pix, width=120, height=120, fc='coral',\n-                         alpha=0.5)\n-    intermediate_transform = e.get_transform()\n-    assert not e.is_transform_set()\n-    ax.add_patch(e)\n-    assert e.get_transform() != intermediate_transform\n-    assert e.is_transform_set()\n-    assert e._transform == ax.transData\n-\n-\n-def test_collection_transform_of_none():\n-    # tests the behaviour of collections added to an Axes with various\n-    # transform specifications\n-\n-    ax = plt.axes()\n-    ax.set_xlim([1, 3])\n-    ax.set_ylim([1, 3])\n-\n-    # draw an ellipse over data coord (2, 2) by specifying device coords\n-    xy_data = (2, 2)\n-    xy_pix = ax.transData.transform(xy_data)\n-\n-    # not providing a transform of None puts the ellipse in data coordinates\n-    e = mpatches.Ellipse(xy_data, width=1, height=1)\n-    c = mcollections.PatchCollection([e], facecolor='yellow', alpha=0.5)\n-    ax.add_collection(c)\n-    # the collection should be in data coordinates\n-    assert c.get_offset_transform() + c.get_transform() == ax.transData\n-\n-    # providing a transform of None puts the ellipse in device coordinates\n-    e = mpatches.Ellipse(xy_pix, width=120, height=120)\n-    c = mcollections.PatchCollection([e], facecolor='coral',\n-                                     alpha=0.5)\n-    c.set_transform(None)\n-    ax.add_collection(c)\n-    assert isinstance(c.get_transform(), mtransforms.IdentityTransform)\n-\n-    # providing an IdentityTransform puts the ellipse in device coordinates\n-    e = mpatches.Ellipse(xy_pix, width=100, height=100)\n-    c = mcollections.PatchCollection([e],\n-                                     transform=mtransforms.IdentityTransform(),\n-                                     alpha=0.5)\n-    ax.add_collection(c)\n-    assert isinstance(c.get_offset_transform(), mtransforms.IdentityTransform)\n-\n-\n-@image_comparison([\"clip_path_clipping\"], remove_text=True)\n-def test_clipping():\n-    exterior = mpath.Path.unit_rectangle().deepcopy()\n-    exterior.vertices *= 4\n-    exterior.vertices -= 2\n-    interior = mpath.Path.unit_circle().deepcopy()\n-    interior.vertices = interior.vertices[::-1]\n-    clip_path = mpath.Path.make_compound_path(exterior, interior)\n-\n-    star = mpath.Path.unit_regular_star(6).deepcopy()\n-    star.vertices *= 2.6\n-\n-    fig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)\n-\n-    col = mcollections.PathCollection([star], lw=5, edgecolor='blue',\n-                                      facecolor='red', alpha=0.7, hatch='*')\n-    col.set_clip_path(clip_path, ax1.transData)\n-    ax1.add_collection(col)\n-\n-    patch = mpatches.PathPatch(star, lw=5, edgecolor='blue', facecolor='red',\n-                               alpha=0.7, hatch='*')\n-    patch.set_clip_path(clip_path, ax2.transData)\n-    ax2.add_patch(patch)\n-\n-    ax1.set_xlim([-3, 3])\n-    ax1.set_ylim([-3, 3])\n-\n-\n-@check_figures_equal(extensions=['png'])\n-def test_clipping_zoom(fig_test, fig_ref):\n-    # This test places the Axes and sets its limits such that the clip path is\n-    # outside the figure entirely. This should not break the clip path.\n-    ax_test = fig_test.add_axes([0, 0, 1, 1])\n-    l, = ax_test.plot([-3, 3], [-3, 3])\n-    # Explicit Path instead of a Rectangle uses clip path processing, instead\n-    # of a clip box optimization.\n-    p = mpath.Path([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])\n-    p = mpatches.PathPatch(p, transform=ax_test.transData)\n-    l.set_clip_path(p)\n-\n-    ax_ref = fig_ref.add_axes([0, 0, 1, 1])\n-    ax_ref.plot([-3, 3], [-3, 3])\n-\n-    ax_ref.set(xlim=(0.5, 0.75), ylim=(0.5, 0.75))\n-    ax_test.set(xlim=(0.5, 0.75), ylim=(0.5, 0.75))\n-\n-\n-def test_cull_markers():\n-    x = np.random.random(20000)\n-    y = np.random.random(20000)\n-\n-    fig, ax = plt.subplots()\n-    ax.plot(x, y, 'k.')\n-    ax.set_xlim(2, 3)\n-\n-    pdf = io.BytesIO()\n-    fig.savefig(pdf, format=\"pdf\")\n-    assert len(pdf.getvalue()) < 8000\n-\n-    svg = io.BytesIO()\n-    fig.savefig(svg, format=\"svg\")\n-    assert len(svg.getvalue()) < 20000\n-\n-\n-@image_comparison(['hatching'], remove_text=True, style='default')\n-def test_hatching():\n-    fig, ax = plt.subplots(1, 1)\n-\n-    # Default hatch color.\n-    rect1 = mpatches.Rectangle((0, 0), 3, 4, hatch='/')\n-    ax.add_patch(rect1)\n-\n-    rect2 = mcollections.RegularPolyCollection(\n-        4, sizes=[16000], offsets=[(1.5, 6.5)], offset_transform=ax.transData,\n-        hatch='/')\n-    ax.add_collection(rect2)\n-\n-    # Ensure edge color is not applied to hatching.\n-    rect3 = mpatches.Rectangle((4, 0), 3, 4, hatch='/', edgecolor='C1')\n-    ax.add_patch(rect3)\n-\n-    rect4 = mcollections.RegularPolyCollection(\n-        4, sizes=[16000], offsets=[(5.5, 6.5)], offset_transform=ax.transData,\n-        hatch='/', edgecolor='C1')\n-    ax.add_collection(rect4)\n-\n-    ax.set_xlim(0, 7)\n-    ax.set_ylim(0, 9)\n-\n-\n-def test_remove():\n-    fig, ax = plt.subplots()\n-    im = ax.imshow(np.arange(36).reshape(6, 6))\n-    ln, = ax.plot(range(5))\n-\n-    assert fig.stale\n-    assert ax.stale\n-\n-    fig.canvas.draw()\n-    assert not fig.stale\n-    assert not ax.stale\n-    assert not ln.stale\n-\n-    assert im in ax._mouseover_set\n-    assert ln not in ax._mouseover_set\n-    assert im.axes is ax\n-\n-    im.remove()\n-    ln.remove()\n-\n-    for art in [im, ln]:\n-        assert art.axes is None\n-        assert art.figure is None\n-\n-    assert im not in ax._mouseover_set\n-    assert fig.stale\n-    assert ax.stale\n-\n-\n-@image_comparison([\"default_edges.png\"], remove_text=True, style='default')\n-def test_default_edges():\n-    # Remove this line when this test image is regenerated.\n-    plt.rcParams['text.kerning_factor'] = 6\n-\n-    fig, [[ax1, ax2], [ax3, ax4]] = plt.subplots(2, 2)\n-\n-    ax1.plot(np.arange(10), np.arange(10), 'x',\n-             np.arange(10) + 1, np.arange(10), 'o')\n-    ax2.bar(np.arange(10), np.arange(10), align='edge')\n-    ax3.text(0, 0, \"BOX\", size=24, bbox=dict(boxstyle='sawtooth'))\n-    ax3.set_xlim((-1, 1))\n-    ax3.set_ylim((-1, 1))\n-    pp1 = mpatches.PathPatch(\n-        mpath.Path([(0, 0), (1, 0), (1, 1), (0, 0)],\n-                   [mpath.Path.MOVETO, mpath.Path.CURVE3,\n-                    mpath.Path.CURVE3, mpath.Path.CLOSEPOLY]),\n-        fc=\"none\", transform=ax4.transData)\n-    ax4.add_patch(pp1)\n-\n-\n-def test_properties():\n-    ln = mlines.Line2D([], [])\n-    ln.properties()  # Check that no warning is emitted.\n-\n-\n-def test_setp():\n-    # Check empty list\n-    plt.setp([])\n-    plt.setp([[]])\n-\n-    # Check arbitrary iterables\n-    fig, ax = plt.subplots()\n-    lines1 = ax.plot(range(3))\n-    lines2 = ax.plot(range(3))\n-    martist.setp(chain(lines1, lines2), 'lw', 5)\n-    plt.setp(ax.spines.values(), color='green')\n-\n-    # Check *file* argument\n-    sio = io.StringIO()\n-    plt.setp(lines1, 'zorder', file=sio)\n-    assert sio.getvalue() == '  zorder: float\\n'\n-\n+import matplotlib as mpl\n+from matplotlib.testing.decorators import image_comparison\n+import pytest\n \n-def test_None_zorder():\n+def test_boundarynorm_cursor_data():\n+    \"\"\"Test that cursor data formatting works with BoundaryNorm.\"\"\"\n     fig, ax = plt.subplots()\n-    ln, = ax.plot(range(5), zorder=None)\n-    assert ln.get_zorder() == mlines.Line2D.zorder\n-    ln.set_zorder(123456)\n-    assert ln.get_zorder() == 123456\n-    ln.set_zorder(None)\n-    assert ln.get_zorder() == mlines.Line2D.zorder\n-\n-\n-@pytest.mark.parametrize('accept_clause, expected', [\n-    ('', 'unknown'),\n-    (\"ACCEPTS: [ '-' | '--' | '-.' ]\", \"[ '-' | '--' | '-.' ]\"),\n-    ('ACCEPTS: Some description.', 'Some description.'),\n-    ('.. ACCEPTS: Some description.', 'Some description.'),\n-    ('arg : int', 'int'),\n-    ('*arg : int', 'int'),\n-    ('arg : int\\nACCEPTS: Something else.', 'Something else. '),\n-])\n-def test_artist_inspector_get_valid_values(accept_clause, expected):\n-    class TestArtist(martist.Artist):\n-        def set_f(self, arg):\n-            pass\n-\n-    TestArtist.set_f.__doc__ = \"\"\"\n-    Some text.\n-\n-    %s\n-    \"\"\" % accept_clause\n-    valid_values = martist.ArtistInspector(TestArtist).get_valid_values('f')\n-    assert valid_values == expected\n-\n-\n-def test_artist_inspector_get_aliases():\n-    # test the correct format and type of get_aliases method\n-    ai = martist.ArtistInspector(mlines.Line2D)\n-    aliases = ai.get_aliases()\n-    assert aliases[\"linewidth\"] == {\"lw\"}\n-\n-\n-def test_set_alpha():\n-    art = martist.Artist()\n-    with pytest.raises(TypeError, match='^alpha must be numeric or None'):\n-        art.set_alpha('string')\n-    with pytest.raises(TypeError, match='^alpha must be numeric or None'):\n-        art.set_alpha([1, 2, 3])\n-    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n-        art.set_alpha(1.1)\n-    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n-        art.set_alpha(np.nan)\n-\n-\n-def test_set_alpha_for_array():\n-    art = martist.Artist()\n-    with pytest.raises(TypeError, match='^alpha must be numeric or None'):\n-        art._set_alpha_for_array('string')\n-    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n-        art._set_alpha_for_array(1.1)\n-    with pytest.raises(ValueError, match=\"outside 0-1 range\"):\n-        art._set_alpha_for_array(np.nan)\n-    with pytest.raises(ValueError, match=\"alpha must be between 0 and 1\"):\n-        art._set_alpha_for_array([0.5, 1.1])\n-    with pytest.raises(ValueError, match=\"alpha must be between 0 and 1\"):\n-        art._set_alpha_for_array([0.5, np.nan])\n-\n-\n-def test_callbacks():\n-    def func(artist):\n-        func.counter += 1\n-\n-    func.counter = 0\n-\n-    art = martist.Artist()\n-    oid = art.add_callback(func)\n-    assert func.counter == 0\n-    art.pchanged()  # must call the callback\n-    assert func.counter == 1\n-    art.set_zorder(10)  # setting a property must also call the callback\n-    assert func.counter == 2\n-    art.remove_callback(oid)\n-    art.pchanged()  # must not call the callback anymore\n-    assert func.counter == 2\n-\n-\n-def test_set_signature():\n-    \"\"\"Test autogenerated ``set()`` for Artist subclasses.\"\"\"\n-    class MyArtist1(martist.Artist):\n-        def set_myparam1(self, val):\n-            pass\n-\n-    assert hasattr(MyArtist1.set, '_autogenerated_signature')\n-    assert 'myparam1' in MyArtist1.set.__doc__\n-\n-    class MyArtist2(MyArtist1):\n-        def set_myparam2(self, val):\n-            pass\n-\n-    assert hasattr(MyArtist2.set, '_autogenerated_signature')\n-    assert 'myparam1' in MyArtist2.set.__doc__\n-    assert 'myparam2' in MyArtist2.set.__doc__\n-\n-\n-def test_set_is_overwritten():\n-    \"\"\"set() defined in Artist subclasses should not be overwritten.\"\"\"\n-    class MyArtist3(martist.Artist):\n-\n-        def set(self, **kwargs):\n-            \"\"\"Not overwritten.\"\"\"\n-\n-    assert not hasattr(MyArtist3.set, '_autogenerated_signature')\n-    assert MyArtist3.set.__doc__ == \"Not overwritten.\"\n-\n-    class MyArtist4(MyArtist3):\n-        pass\n-\n-    assert MyArtist4.set is MyArtist3.set\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(10, 10)\n+    pc = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # Test that format_cursor_data doesn't raise an exception\n+    data = X[0, 0]\n+    result = pc.format_cursor_data(data)\n+    assert isinstance(result, str)\n+    \n+    # Test with array data\n+    data = X[0:2, 0]\n+    result = pc.format_cursor_data(data)\n+    assert isinstance(result, str)\n+    \n+    plt.close(fig)\n",
  "model_name_or_path": "KortixAI"
}