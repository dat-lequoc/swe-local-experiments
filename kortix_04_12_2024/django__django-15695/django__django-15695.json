{
  "instance_id": "django__django-15695",
  "model_patch": "diff --git a/django/db/migrations/operations/indexes.py b/django/db/migrations/operations/indexes.py\nnew file mode 100644\nindex 0000000000..a8d8570e49\n--- /dev/null\n+++ b/django/db/migrations/operations/indexes.py\n@@ -0,0 +1,74 @@\n+from django.db.migrations.operations.base import Operation\n+from django.db.models import Index\n+\n+\n+class RenameIndex(Operation):\n+    reduces_to_sql = True\n+    reversible = True\n+\n+    def __init__(self, model_name, old_name, new_name):\n+        self.model_name = model_name\n+        self.old_name = old_name\n+        self.new_name = new_name\n+\n+    def state_forwards(self, app_label, state):\n+        pass\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        model = from_state.apps.get_model(app_label, self.model_name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, model):\n+            # Check if index exists before renaming\n+            with schema_editor.connection.cursor() as cursor:\n+                constraints = schema_editor.connection.introspection.get_constraints(\n+                    cursor, model._meta.db_table\n+                )\n+                if self.old_name in constraints:\n+                    old_constraint = constraints[self.old_name]\n+                    # Only rename if target doesn't exist or is different\n+                    if self.new_name not in constraints or constraints[self.new_name] != old_constraint:\n+                        if self.new_name in constraints:\n+                            schema_editor.execute(schema_editor._delete_index_sql(model, self.new_name))\n+                        schema_editor.rename_index(model, self.old_name, self.new_name)\n+                elif self.new_name in constraints:\n+                    # If old name doesn't exist but new name does, we're likely re-running\n+                    # a previously completed migration - no action needed\n+                    pass\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        model = from_state.apps.get_model(app_label, self.model_name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, model):\n+            # Check if index exists before renaming\n+            with schema_editor.connection.cursor() as cursor:\n+                constraints = schema_editor.connection.introspection.get_constraints(\n+                    cursor, model._meta.db_table\n+                )\n+                if self.new_name in constraints:\n+                    new_constraint = constraints[self.new_name]\n+                    # Only rename if target doesn't exist or is different\n+                    if self.old_name not in constraints or constraints[self.old_name] != new_constraint:\n+                        if self.old_name in constraints:\n+                            schema_editor.execute(schema_editor._delete_index_sql(model, self.old_name))\n+                        schema_editor.rename_index(model, self.new_name, self.old_name)\n+                elif self.old_name in constraints:\n+                    # If new name doesn't exist but old name does, we're likely re-running\n+                    # a previously completed backward migration - no action needed\n+                    pass\n+\n+    def describe(self):\n+        return \"Rename index %s on %s to %s\" % (\n+            self.old_name,\n+            self.model_name,\n+            self.new_name,\n+        )\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"model_name\": self.model_name,\n+            \"old_name\": self.old_name,\n+            \"new_name\": self.new_name,\n+        }\n+        return (self.__class__.__name__, [], kwargs)\n+\n+    @property\n+    def migration_name_fragment(self):\n+        return \"%s_rename_%s\" % (self.old_name, self.new_name)\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}