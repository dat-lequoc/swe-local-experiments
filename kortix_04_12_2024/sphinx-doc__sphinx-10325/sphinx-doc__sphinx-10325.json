{
  "instance_id": "sphinx-doc__sphinx-10325",
  "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..19f9e3d7f 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,21 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n-def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+def inherited_members_option(arg: Any) -> Union[str, List[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\n+    \n+    Accepts:\n+    - None/True: Include all inherited members (returns 'object')\n+    - str: Single class name to exclude\n+    - comma-separated str: Multiple class names to exclude\n+    \"\"\"\n     if arg in (None, True):\n         return 'object'\n-    else:\n-        return arg\n+    elif isinstance(arg, str):\n+        if ',' in arg:\n+            return [name.strip() for name in arg.split(',')]\n+        return arg.strip()\n+    return arg\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -636,6 +645,23 @@ class Documenter:\n             for line, src in zip(more_content.data, more_content.items):\n                 self.add_line(line, src[0], src[1])\n \n+    def _is_class_member_from(self, member_class: Any, base_name: str) -> bool:\n+        \"\"\"Check if a member comes from a specific base class.\n+        \n+        Args:\n+            member_class: The class to check\n+            base_name: The base class name (can be qualified or unqualified)\n+        \"\"\"\n+        if not member_class:\n+            return False\n+            \n+        for cls in getattr(member_class, '__mro__', []):\n+            # Check both qualified and unqualified names\n+            if (cls.__module__ + \".\" + cls.__name__ == base_name or\n+                cls.__name__ == base_name):\n+                return True\n+        return False\n+\n     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n         \"\"\"Return `(members_check_module, members)` where `members` is a\n         list of `(membername, member)` pairs of the members of *self.object*.\n@@ -664,6 +690,57 @@ class Documenter:\n             return False, [(m.name, m.value) for m in members.values()\n                            if m.directly_defined]\n \n+    def _is_class_member_from(self, member_class: Any, base_name: str) -> bool:\n+        \"\"\"Check if a member comes from a specific base class.\n+        \n+        Args:\n+            member_class: The class to check\n+            base_name: The base class name (can be qualified or unqualified)\n+        \"\"\"\n+        if not member_class:\n+            return False\n+            \n+        for cls in getattr(member_class, '__mro__', []):\n+            # Check both qualified and unqualified names\n+            if (cls.__module__ + \".\" + cls.__name__ == base_name or\n+                cls.__name__ == base_name):\n+                return True\n+        return False\n+\n+    def _is_class_member_from(self, member_class: Any, base_name: str) -> bool:\n+        \"\"\"Check if a member comes from a specific base class.\n+        \n+        Args:\n+            member_class: The class to check\n+            base_name: The base class name (can be qualified or unqualified)\n+        \"\"\"\n+        if not member_class:\n+            return False\n+            \n+        for cls in getattr(member_class, '__mro__', []):\n+            # Check both qualified and unqualified names\n+            if (cls.__module__ + \".\" + cls.__name__ == base_name or\n+                cls.__name__ == base_name):\n+                return True\n+        return False\n+\n+    def _is_class_member_from(self, member_class: Any, base_name: str) -> bool:\n+        \"\"\"Check if a member comes from a specific base class.\n+        \n+        Args:\n+            member_class: The class to check\n+            base_name: The base class name (can be qualified or unqualified)\n+        \"\"\"\n+        if not member_class:\n+            return False\n+            \n+        for cls in getattr(member_class, '__mro__', []):\n+            # Check both qualified and unqualified names\n+            if (cls.__module__ + \".\" + cls.__name__ == base_name or\n+                cls.__name__ == base_name):\n+                return True\n+        return False\n+\n     def filter_members(self, members: ObjectMembers, want_all: bool\n                        ) -> List[Tuple[str, Any, bool]]:\n         \"\"\"Filter the given member list.\n@@ -681,11 +758,17 @@ class Documenter:\n         \"\"\"\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n+                bases = self.options.inherited_members\n+                if isinstance(bases, str):\n+                    bases = [bases]\n+                    \n                 for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n+                    # Check if this class should be excluded\n+                    for base in bases:\n+                        if self._is_class_member_from(cls, base) and cls != self.object:\n+                            return True\n+                            \n+                    if name in cls.__dict__:\n                         return False\n                     elif name in self.get_attr(cls, '__annotations__', {}):\n                         return False\n@@ -2900,4 +2983,4 @@ def setup(app: Sphinx) -> Dict[str, Any]:\n     app.setup_extension('sphinx.ext.autodoc.type_comment')\n     app.setup_extension('sphinx.ext.autodoc.typehints')\n \n-    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n+    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n\\ No newline at end of file\ndiff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex 1f1c7e9e7..698196956 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -769,6 +769,25 @@ def test_autodoc_inherited_members(app):\n         '   .. py:method:: Derived.inheritedstaticmeth(cls)',\n     ]\n \n+def test_autodoc_inherited_members_multiple_bases(app):\n+    # Test with single base class\n+    options = {\"members\": None,\n+               \"inherited-members\": \"Base\"}\n+    actual = do_autodoc(app, 'class', 'target.inheritance.Derived', options)\n+    assert list(filter(lambda l: 'method::' in l, actual)) == []\n+\n+    # Test with multiple base classes\n+    options = {\"members\": None,\n+               \"inherited-members\": \"Base,object\"}\n+    actual = do_autodoc(app, 'class', 'target.inheritance.Derived', options)\n+    assert list(filter(lambda l: 'method::' in l, actual)) == []\n+\n+    # Test with qualified name\n+    options = {\"members\": None,\n+               \"inherited-members\": \"target.inheritance.Base\"}\n+    actual = do_autodoc(app, 'class', 'target.inheritance.Derived', options)\n+    assert list(filter(lambda l: 'method::' in l, actual)) == []\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_autodoc_inherited_members_Base(app):\n@@ -2507,4 +2526,4 @@ def test_canonical(app):\n         '',\n         '      docstring',\n         '',\n-    ]\n+    ]\n\\ No newline at end of file\ndiff --git a/tox.ini b/tox.ini\nindex f0afd779b..30ca90275 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -28,7 +28,7 @@ setenv =\n     PYTHONWARNINGS = all\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -m pytest --durations 25 {posargs}\n+    python -X dev -m pytest -rA --durations 25 {posargs}\n \n [testenv:du-latest]\n commands =\n",
  "model_name_or_path": "KortixAI"
}