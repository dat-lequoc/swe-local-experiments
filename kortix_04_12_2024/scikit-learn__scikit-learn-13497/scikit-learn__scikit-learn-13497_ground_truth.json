{
  "patch": "diff --git a/sklearn/feature_selection/mutual_info_.py b/sklearn/feature_selection/mutual_info_.py\n--- a/sklearn/feature_selection/mutual_info_.py\n+++ b/sklearn/feature_selection/mutual_info_.py\n@@ -10,7 +10,7 @@\n from ..preprocessing import scale\n from ..utils import check_random_state\n from ..utils.fixes import _astype_copy_false\n-from ..utils.validation import check_X_y\n+from ..utils.validation import check_array, check_X_y\n from ..utils.multiclass import check_classification_targets\n \n \n@@ -247,14 +247,16 @@ def _estimate_mi(X, y, discrete_features='auto', discrete_target=False,\n     X, y = check_X_y(X, y, accept_sparse='csc', y_numeric=not discrete_target)\n     n_samples, n_features = X.shape\n \n-    if discrete_features == 'auto':\n-        discrete_features = issparse(X)\n-\n-    if isinstance(discrete_features, bool):\n+    if isinstance(discrete_features, (str, bool)):\n+        if isinstance(discrete_features, str):\n+            if discrete_features == 'auto':\n+                discrete_features = issparse(X)\n+            else:\n+                raise ValueError(\"Invalid string value for discrete_features.\")\n         discrete_mask = np.empty(n_features, dtype=bool)\n         discrete_mask.fill(discrete_features)\n     else:\n-        discrete_features = np.asarray(discrete_features)\n+        discrete_features = check_array(discrete_features, ensure_2d=False)\n         if discrete_features.dtype != 'bool':\n             discrete_mask = np.zeros(n_features, dtype=bool)\n             discrete_mask[discrete_features] = True\n",
  "test_patch": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -183,18 +183,26 @@ def test_mutual_info_options():\n     X_csr = csr_matrix(X)\n \n     for mutual_info in (mutual_info_regression, mutual_info_classif):\n-        assert_raises(ValueError, mutual_info_regression, X_csr, y,\n+        assert_raises(ValueError, mutual_info, X_csr, y,\n                       discrete_features=False)\n+        assert_raises(ValueError, mutual_info, X, y,\n+                      discrete_features='manual')\n+        assert_raises(ValueError, mutual_info, X_csr, y,\n+                      discrete_features=[True, False, True])\n+        assert_raises(IndexError, mutual_info, X, y,\n+                      discrete_features=[True, False, True, False])\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[1, 4])\n \n         mi_1 = mutual_info(X, y, discrete_features='auto', random_state=0)\n         mi_2 = mutual_info(X, y, discrete_features=False, random_state=0)\n-\n-        mi_3 = mutual_info(X_csr, y, discrete_features='auto',\n-                           random_state=0)\n-        mi_4 = mutual_info(X_csr, y, discrete_features=True,\n+        mi_3 = mutual_info(X_csr, y, discrete_features='auto', random_state=0)\n+        mi_4 = mutual_info(X_csr, y, discrete_features=True, random_state=0)\n+        mi_5 = mutual_info(X, y, discrete_features=[True, False, True],\n                            random_state=0)\n+        mi_6 = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n \n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n+        assert_array_equal(mi_5, mi_6)\n \n     assert not np.allclose(mi_1, mi_3)\n"
}