{
  "instance_id": "mwaskom__seaborn-3010",
  "model_patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..53fd52c5 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -20,18 +20,27 @@ class PolyFit(Stat):\n     gridsize: int = 100\n \n     def _fit_predict(self, data):\n-\n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n-            # TODO warn?\n-            xx = yy = []\n-        else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n-            yy = np.polyval(p, xx)\n-\n-        return pd.DataFrame(dict(x=xx, y=yy))\n+        # Convert to pandas Series first for proper NA handling\n+        x = pd.Series(data[\"x\"])\n+        y = pd.Series(data[\"y\"])\n+        \n+        # Use pandas isna() which handles None properly\n+        mask = ~(x.isna() | y.isna())\n+        x_clean = x[mask]\n+        y_clean = y[mask]\n+        \n+        if len(x_clean) <= self.order:\n+            return pd.DataFrame({\"x\": [], \"y\": []})\n+        \n+        # Convert to numpy arrays after cleaning\n+        x_np = x_clean.to_numpy()\n+        y_np = y_clean.to_numpy()\n+        \n+        p = np.polyfit(x_np, y_np, self.order)\n+        xx = np.linspace(x_np.min(), x_np.max(), self.gridsize)\n+        yy = np.polyval(p, xx)\n+        \n+        return pd.DataFrame({\"x\": xx, \"y\": yy})\n \n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n@@ -44,4 +53,4 @@ class PolyFit(Stat):\n @dataclass\n class OLSFit(Stat):\n \n-    ...\n+    ...\n\\ No newline at end of file\ndiff --git a/tests/test_stats.py b/tests/test_stats.py\nnew file mode 100644\nindex 00000000..9e23d821\n--- /dev/null\n+++ b/tests/test_stats.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+import pandas as pd\n+import pytest\n+from seaborn._stats.regression import PolyFit\n+\n+def test_polyfit_with_none_values():\n+    # Test handling of None values\n+    data = pd.DataFrame({\n+        \"x\": [1, 2, 3, None, 4],\n+        \"y\": [1, 2, 3, 4, 5]\n+    })\n+    fit = PolyFit(order=2)\n+    result = fit._fit_predict(data)\n+    assert isinstance(result, pd.DataFrame)\n+    assert set(result.columns) == {\"x\", \"y\"}\n+    assert len(result) > 0\n+\n+def test_polyfit_edge_cases():\n+    fit = PolyFit(order=2)\n+    \n+    # Test empty data\n+    empty = pd.DataFrame({\"x\": [], \"y\": []})\n+    result = fit._fit_predict(empty)\n+    assert len(result) == 0\n+    \n+    # Test insufficient data\n+    small = pd.DataFrame({\"x\": [1], \"y\": [1]})\n+    result = fit._fit_predict(small)\n+    assert len(result) == 0\n+    \n+    # Test all None\n+    all_none = pd.DataFrame({\n+        \"x\": [None, None],\n+        \"y\": [None, None]\n+    })\n+    result = fit._fit_predict(all_none)\n+    assert len(result) == 0\n",
  "model_name_or_path": "KortixAI"
}