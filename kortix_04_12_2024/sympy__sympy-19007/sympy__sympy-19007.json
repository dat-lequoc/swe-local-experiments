{
  "instance_id": "sympy__sympy-19007",
  "model_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex b821c42845..530b94d7dd 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -233,18 +233,48 @@ def transpose(self):\n         return self._eval_transpose()\n \n     def _entry(self, i, j, **kwargs):\n-        # Find row entry\n-        for row_block, numrows in enumerate(self.rowblocksizes):\n-            if (i < numrows) != False:\n-                break\n-            else:\n-                i -= numrows\n-        for col_block, numcols in enumerate(self.colblocksizes):\n-            if (j < numcols) != False:\n-                break\n-            else:\n-                j -= numcols\n-        return self.blocks[row_block, col_block][i, j]\n+        from sympy import Piecewise, And\n+        from sympy.core.relational import LessThan\n+        \n+        # Track cumulative sizes for rows\n+        cumul_rows = [0]\n+        total = 0\n+        for size in self.rowblocksizes:\n+            total += size\n+            cumul_rows.append(total)\n+            \n+        # Track cumulative sizes for columns\n+        cumul_cols = [0]\n+        total = 0\n+        for size in self.colblocksizes:\n+            total += size\n+            cumul_cols.append(total)\n+            \n+        # Build piecewise expression for the element\n+        pieces = []\n+        for row_block in range(len(self.rowblocksizes)):\n+            for col_block in range(len(self.colblocksizes)):\n+                # Calculate local indices\n+                row_start = cumul_rows[row_block]\n+                col_start = cumul_cols[col_block]\n+                \n+                # Condition for this block\n+                cond = And(\n+                    LessThan(row_start, i + 1),\n+                    LessThan(i, cumul_rows[row_block + 1]),\n+                    LessThan(col_start, j + 1),\n+                    LessThan(j, cumul_cols[col_block + 1])\n+                )\n+                \n+                # Map to local indices\n+                local_i = i - row_start\n+                local_j = j - col_start\n+                \n+                pieces.append(\n+                    (self.blocks[row_block, col_block][local_i, local_j], cond)\n+                )\n+                \n+        return Piecewise(*pieces)\n \n     @property\n     def is_Identity(self):\n@@ -568,4 +598,4 @@ def blockcut(expr, rowsizes, colsizes):\n     colbounds = bounds(colsizes)\n     return BlockMatrix([[MatrixSlice(expr, rowbound, colbound)\n                          for colbound in colbounds]\n-                         for rowbound in rowbounds])\n+                         for rowbound in rowbounds])\n\\ No newline at end of file\ndiff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex da17b9dbb5..c66f90226d 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -57,6 +57,17 @@ def test_BlockMatrix():\n     X = BlockMatrix(Matrix([[A, B], [C, D]]))\n \n     assert X.__class__(*X.args) == X\n+    \n+    # Test symbolic index access\n+    from sympy import symbols\n+    n, i = symbols('n, i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    expr = C[i, 0]\n+    # The result should be a Piecewise expression that considers both blocks\n+    assert expr.is_Piecewise\n+    # The expression should have conditions for both A and B blocks\n \n     # block_collapse does nothing on normal inputs\n     E = MatrixSymbol('E', n, m)\n@@ -231,4 +242,4 @@ def test_block_collapse_type():\n     assert block_collapse(Inverse(bm1)).__class__ == BlockDiagMatrix\n     assert block_collapse(Transpose(bm1)).__class__ == BlockDiagMatrix\n     assert bc_transpose(Transpose(bm1)).__class__ == BlockDiagMatrix\n-    assert bc_inverse(Inverse(bm1)).__class__ == BlockDiagMatrix\n+    assert bc_inverse(Inverse(bm1)).__class__ == BlockDiagMatrix\n\\ No newline at end of file\n",
  "model_name_or_path": "KortixAI"
}