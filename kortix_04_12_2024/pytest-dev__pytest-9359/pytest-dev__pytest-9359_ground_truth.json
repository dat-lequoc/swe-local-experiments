{
  "patch": "diff --git a/src/_pytest/_code/source.py b/src/_pytest/_code/source.py\n--- a/src/_pytest/_code/source.py\n+++ b/src/_pytest/_code/source.py\n@@ -149,6 +149,11 @@ def get_statement_startend2(lineno: int, node: ast.AST) -> Tuple[int, Optional[i\n     values: List[int] = []\n     for x in ast.walk(node):\n         if isinstance(x, (ast.stmt, ast.ExceptHandler)):\n+            # Before Python 3.8, the lineno of a decorated class or function pointed at the decorator.\n+            # Since Python 3.8, the lineno points to the class/def, so need to include the decorators.\n+            if isinstance(x, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):\n+                for d in x.decorator_list:\n+                    values.append(d.lineno - 1)\n             values.append(x.lineno - 1)\n             for name in (\"finalbody\", \"orelse\"):\n                 val: Optional[List[ast.stmt]] = getattr(x, name, None)\n",
  "test_patch": "diff --git a/testing/code/test_source.py b/testing/code/test_source.py\n--- a/testing/code/test_source.py\n+++ b/testing/code/test_source.py\n@@ -618,6 +618,19 @@ def something():\n     assert str(source) == \"def func(): raise ValueError(42)\"\n \n \n+def test_decorator() -> None:\n+    s = \"\"\"\\\n+def foo(f):\n+    pass\n+\n+@foo\n+def bar():\n+    pass\n+    \"\"\"\n+    source = getstatement(3, s)\n+    assert \"@foo\" in str(source)\n+\n+\n def XXX_test_expression_multiline() -> None:\n     source = \"\"\"\\\n something\n"
}