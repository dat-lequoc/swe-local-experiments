{"instance_id": "django__django-11001", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39262..2b9e40053d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -353,7 +353,9 @@ class SQLCompiler:\n             # not taken into account so we strip it. When this entire method\n             # is refactored into expressions, then we can check each part as we\n             # generate it.\n-            without_ordering = self.ordering_parts.search(sql).group(1)\n+            # Normalize SQL to handle multiline expressions\n+            sql_normalized = ' '.join(sql.split())\n+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n             params_hash = make_hashable(params)\n             if (without_ordering, params_hash) in seen:\n                 continue\n@@ -366,7 +368,9 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                # Normalize SQL to handle multiline expressions\n+            sql_normalized = ' '.join(sql.split())\n+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select\n@@ -1504,4 +1508,4 @@ def cursor_iter(cursor, sentinel, col_count, itersize):\n         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):\n             yield rows if col_count is None else [r[:col_count] for r in rows]\n     finally:\n-        cursor.close()\n+        cursor.close()\n\\ No newline at end of file\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex bce514c0bf..470845be9c 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -622,6 +622,23 @@ class Queries1Tests(TestCase):\n             Tag.objects.filter(parent=self.t1, name='t3').order_by('name'),\n             ['<Tag: t3>']\n         )\n+        \n+    def test_multiline_rawsql_ordering(self):\n+        \"\"\"Test that multiline RawSQL expressions in order_by work correctly.\"\"\"\n+        qs = Tag.objects.all().order_by(\n+            RawSQL('''\n+                CASE WHEN name = 't1'\n+                     THEN 1\n+                     ELSE 2 END''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN name = 't2'\n+                     THEN 1\n+                     ELSE 2 END''', []).desc()\n+        )\n+        # Both order by clauses should be present in the query\n+        sql = str(qs.query)\n+        self.assertIn(\"CASE WHEN name = 't1'\", sql)\n+        self.assertIn(\"CASE WHEN name = 't2'\", sql)\n         self.assertQuerysetEqual(\n             Tag.objects.exclude(parent=self.t1, name='t3').order_by('name'),\n             ['<Tag: t1>', '<Tag: t2>', '<Tag: t4>', '<Tag: t5>']\n@@ -3927,4 +3944,4 @@ class Ticket23622Tests(TestCase):\n             set(Ticket23605A.objects.filter(qx).values_list('pk', flat=True)),\n             set(Ticket23605A.objects.filter(qy).values_list('pk', flat=True))\n         )\n-        self.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])\n+        self.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])\n\\ No newline at end of file\n", "model_name_or_path": "KortixAI"}
{"instance_id": "django__django-10914", "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887d2..9ba30e5b26 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,7 @@ FILE_UPLOAD_TEMP_DIR = None\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\n@@ -631,4 +631,4 @@ SECURE_HSTS_PRELOAD = False\n SECURE_HSTS_SECONDS = 0\n SECURE_REDIRECT_EXEMPT = []\n SECURE_SSL_HOST = None\n-SECURE_SSL_REDIRECT = False\n+SECURE_SSL_REDIRECT = False\n\\ No newline at end of file\ndiff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 434869554c..ffa7c12037 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -488,6 +488,28 @@ class FileStorageTests(SimpleTestCase):\n         with self.assertRaises(OSError):\n             self.storage.save('error.file', f1)\n \n+    def test_file_permissions_for_both_upload_types(self):\n+        \"\"\"\n+        File storage should set consistent permissions for both upload types.\n+        \"\"\"\n+        # Test small file (MemoryUploadedFile)\n+        small_file = SimpleUploadedFile('small.txt', b'small contents')\n+        small_name = self.storage.save('small.txt', small_file)\n+        small_path = self.storage.path(small_name)\n+        small_mode = os.stat(small_path).st_mode & 0o777\n+        self.assertEqual(small_mode, 0o644)\n+        self.storage.delete(small_name)\n+\n+        # Test large file (TemporaryUploadedFile)\n+        large_file = TemporaryUploadedFile('large.txt', 'text/plain', 0, 'utf-8')\n+        large_file.write(b'large contents')\n+        large_file.seek(0)\n+        large_name = self.storage.save('large.txt', large_file)\n+        large_path = self.storage.path(large_name)\n+        large_mode = os.stat(large_path).st_mode & 0o777\n+        self.assertEqual(large_mode, 0o644)\n+        self.storage.delete(large_name)\n+\n     def test_delete_no_name(self):\n         \"\"\"\n         Calling delete with an empty name should not try to remove the base\n@@ -995,4 +1017,4 @@ class FileLikeObjectTestCase(LiveServerTestCase):\n \n         remote_file = urlopen(self.live_server_url + '/')\n         with self.storage.open(stored_filename) as stored_file:\n-            self.assertEqual(stored_file.read(), remote_file.read())\n+            self.assertEqual(stored_file.read(), remote_file.read())\n\\ No newline at end of file\n", "model_name_or_path": "KortixAI"}
{"instance_id": "astropy__astropy-7746", "model_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..53aac3e244 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1212,13 +1212,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n         \"\"\"\n \n         def _return_list_of_arrays(axes, origin):\n+            # Convert inputs to arrays and check for empty inputs\n+            arrays = [np.asarray(x) for x in axes]\n+            if any(x.size == 0 for x in arrays):\n+                # Return empty arrays of correct shape\n+                return [np.array([], dtype=float) for _ in range(self.naxis)]\n+            \n             try:\n-                axes = np.broadcast_arrays(*axes)\n+                arrays = np.broadcast_arrays(*arrays)\n             except ValueError:\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n-            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in arrays])\n \n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n@@ -1231,6 +1237,11 @@ reduce these to 2 dimensions using the naxis kwarg.\n                     for i in range(output.shape[1])]\n \n         def _return_single_array(xy, origin):\n+            # Convert input to array and handle empty input\n+            xy = np.asarray(xy)\n+            if xy.size == 0:\n+                return np.array([]).reshape(0, self.naxis)\n+                \n             if xy.shape[-1] != self.naxis:\n                 raise ValueError(\n                     \"When providing two arguments, the array must be \"\n@@ -3296,4 +3307,4 @@ def validate(source):\n \n                 wcs_results.extend([str(x.message) for x in warning_lines])\n \n-    return results\n+    return results\n\\ No newline at end of file\n", "model_name_or_path": "KortixAI"}
{"instance_id": "django__django-11019", "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..22b995e44e 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -117,37 +117,52 @@ class Media:\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n-        Warn if the lists have the same two elements in a different relative\n-        order.\n+        Merge lists while trying to keep the relative order of the elements.\n+        Warn if there's a genuine circular dependency between files.\n \n         For static assets it can be important to have them included in the DOM\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n+        combined = list(list_1)\n+        positions = {path: i for i, path in enumerate(combined)}\n+        \n+        # Track seen conflicts to avoid duplicate warnings\n+        seen_conflicts = set()\n+        \n+        # Track dependencies to avoid false positives\n+        dependencies = {}\n+        \n+        for path in list_2:\n+            if path in positions:\n+                current_pos = positions[path]\n+                # Check for actual circular dependencies\n+                for i, existing in enumerate(combined[current_pos + 1:], start=current_pos + 1):\n+                    if existing in list_2:\n+                        # Get positions in list_2\n+                        path_idx = list_2.index(path)\n+                        existing_idx = list_2.index(existing)\n+                        \n+                        # Only warn if this creates a genuine circular dependency\n+                        if existing_idx < path_idx:\n+                            # Ensure consistent warning message order\n+                            first, second = sorted([existing, path])\n+                            conflict_key = (first, second)\n+                            if conflict_key not in seen_conflicts:\n+                                seen_conflicts.add(conflict_key)\n+                                warnings.warn(\n+                                    'Detected circular Media file dependencies:\\n%s and %s' % \n+                                    (first, second),\n+                                    MediaOrderConflictWarning,\n+                                )\n+                    # Track dependency\n+                    if existing_idx > path_idx:\n+                        dependencies.setdefault(path, []).append(existing)\n             else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n-                # path already exists in the list. Update last_insert_index so\n-                # that the following elements are inserted in front of this one.\n-                last_insert_index = index\n-        return combined_list\n+                combined.append(path)\n+                positions[path] = len(combined) - 1\n+                \n+        return combined\n \n     def __add__(self, other):\n         combined = Media()\n@@ -1080,4 +1095,4 @@ class SelectDateWidget(Widget):\n         return not any(\n             ('{}_{}'.format(name, interval) in data)\n             for interval in ('year', 'month', 'day')\n-        )\n+        )\n\\ No newline at end of file\ndiff --git a/tests/forms_tests/tests/test_media.py b/tests/forms_tests/tests/test_media.py\nindex 8cb484a15e..c82e2e1cfc 100644\n--- a/tests/forms_tests/tests/test_media.py\n+++ b/tests/forms_tests/tests/test_media.py\n@@ -538,9 +538,27 @@ class FormsMediaTestCase(SimpleTestCase):\n                 self.assertEqual(Media.merge(list1, list2), expected)\n \n     def test_merge_warning(self):\n-        msg = 'Detected duplicate Media files in an opposite order:\\n1\\n2'\n+        msg = 'Detected circular Media file dependencies:\\n1 and 2'\n         with self.assertWarnsMessage(RuntimeWarning, msg):\n             self.assertEqual(Media.merge([1, 2], [2, 1]), [1, 2])\n+            \n+    def test_merge_with_dependencies(self):\n+        \"\"\"Test merging media with dependencies is handled correctly.\"\"\"\n+        # text-editor-extras.js depends on text-editor.js\n+        list1 = ['color-picker.js']\n+        list2 = ['text-editor.js']\n+        list3 = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']\n+        \n+        # Merge first two lists\n+        merged = Media.merge(list1, list2)\n+        # Merge with third list\n+        final = Media.merge(merged, list3)\n+        \n+        # Verify correct ordering\n+        self.assertEqual(\n+            final,\n+            ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']\n+        )\n \n     def test_merge_js_three_way(self):\n         \"\"\"\n@@ -570,4 +588,4 @@ class FormsMediaTestCase(SimpleTestCase):\n         # ...but merging succeeds as the relative ordering of a.css and b.css\n         # was never specified.\n         merged = widget3 + form1 + form2\n-        self.assertEqual(merged._css, {'screen': ['a.css', 'b.css'], 'all': ['c.css']})\n+        self.assertEqual(merged._css, {'screen': ['a.css', 'b.css'], 'all': ['c.css']})\n\\ No newline at end of file\n", "model_name_or_path": "KortixAI"}
{"instance_id": "django__django-10924", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..54f6e4eb49 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1668,6 +1668,37 @@ class FilePathField(Field):\n         kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n+    def get_path(self):\n+        \"\"\"Resolve the path at runtime.\"\"\"\n+        path = self.path\n+        if callable(path):\n+            path = path()\n+        if path is None:\n+            return ''\n+        return os.path.abspath(path)</old_string>\n+        </replacement>\n+        <replacement>\n+            <old_string>    def formfield(self, **kwargs):\n+        return super().formfield(**{\n+            'path': self.get_path(),\n+            'match': self.match,\n+            'recursive': self.recursive,\n+            'form_class': forms.FilePathField,\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })</old_string>\n+            <new_string>    def formfield(self, **kwargs):\n+        return super().formfield(**{\n+            'path': self.get_path(),\n+            'match': self.match,\n+            'recursive': self.recursive,\n+            'form_class': forms.FilePathField,\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })\n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1709,7 +1740,7 @@ class FilePathField(Field):\n \n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self.get_path(),\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n@@ -2365,4 +2396,4 @@ class UUIDField(Field):\n         return super().formfield(**{\n             'form_class': forms.UUIDField,\n             **kwargs,\n-        })\n+        })\n\\ No newline at end of file\ndiff --git a/tests/model_fields/test_filepathfield.py b/tests/model_fields/test_filepathfield.py\nnew file mode 100644\nindex 0000000000..61ba38306c\n--- /dev/null\n+++ b/tests/model_fields/test_filepathfield.py\n@@ -0,0 +1,34 @@\n+import os\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import override_settings\n+\n+class FilePathFieldTests(SimpleTestCase):\n+    def test_filepathfield_callable_path(self):\n+        def get_path():\n+            return os.path.dirname(__file__)\n+\n+        class TestModel(models.Model):\n+            path = models.FilePathField(path=get_path)\n+\n+            class Meta:\n+                app_label = 'model_fields'\n+\n+        field = TestModel._meta.get_field('path')\n+        self.assertEqual(field.path, get_path)\n+        self.assertEqual(field.get_path(), os.path.abspath(os.path.dirname(__file__)))\n+\n+    def test_filepathfield_callable_path_validation(self):\n+        def get_invalid_path():\n+            return '/invalid/path/does/not/exist'\n+\n+        class TestModel(models.Model):\n+            path = models.FilePathField(path=get_invalid_path)\n+\n+            class Meta:\n+                app_label = 'model_fields'\n+\n+        field = TestModel._meta.get_field('path')\n+        self.assertEqual(field.path, get_invalid_path)\n+        self.assertEqual(field.get_path(), os.path.abspath('/invalid/path/does/not/exist'))\n", "model_name_or_path": "KortixAI"}
